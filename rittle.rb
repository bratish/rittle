require "socket"
require "timeout"
require "digest/sha1"
require "stringio"
class Mysql
  
  class Charset
    def initialize(number, name, csname)
      @number, @name, @csname = number, name, csname
      @unsafe = false
    end
    attr_reader :number, :name, :csname
    attr_accessor :unsafe

    # [[charset_number, charset_name, collation_name, default], ...]
    CHARSETS = [[1, "big5", "big5_chinese_ci", true ], [2, "latin2", "latin2_czech_cs", false], [3,"dec8","dec8_swedish_ci",true],[4,"cp850","cp850_general_ci",true],[5,"latin1","latin1_german1_ci",false],[6,"hp8","hp8_english_ci",true],[7,"koi8r","koi8r_general_ci",true],[8,"latin1","latin1_swedish_ci",true],[9,"latin2","latin2_general_ci",true],[10,"swe7","swe7_swedish_ci",true],[11,"ascii","ascii_general_ci",true],[12,"ujis","ujis_japanese_ci",true],[13,"sjis","sjis_japanese_ci",true],[14,"cp1251","cp1251_bulgarian_ci",false],[15,"latin1","latin1_danish_ci",false],[16,"hebrew","hebrew_general_ci",true],[17,"filename","filename",true],[18,"tis620","tis620_thai_ci",true],[19,"euckr","euckr_korean_ci",true],[20,"latin7","latin7_estonian_cs",false],[21,"latin2","latin2_hungarian_ci",false],[22,"koi8u","koi8u_general_ci",true],[23,"cp1251","cp1251_ukrainian_ci",false],[24,"gb2312","gb2312_chinese_ci",true],[25,"greek","greek_general_ci",true],[26,"cp1250","cp1250_general_ci",true],[27,"latin2","latin2_croatian_ci",false],[28,"gbk","gbk_chinese_ci",true],[29,"cp1257","cp1257_lithuanian_ci",false],[30,"latin5","latin5_turkish_ci",true],[31,"latin1","latin1_german2_ci",false],[32,"armscii8","armscii8_general_ci",true],[33,"utf8","utf8_general_ci",true],[34,"cp1250","cp1250_czech_cs",false],[35,"ucs2","ucs2_general_ci",true],[36,"cp866","cp866_general_ci",true],[37,"keybcs2","keybcs2_general_ci",true],[38,"macce","macce_general_ci",true],[39,"macroman","macroman_general_ci",true],[40,"cp852","cp852_general_ci",true],[41,"latin7","latin7_general_ci",true],[42,"latin7","latin7_general_cs",false],[43,"macce","macce_bin",false],[44,"cp1250","cp1250_croatian_ci",false],[47,"latin1","latin1_bin",false],[48,"latin1","latin1_general_ci",false],[49,"latin1","latin1_general_cs",false],[50,"cp1251","cp1251_bin",false],[51,"cp1251","cp1251_general_ci",true],[52,"cp1251","cp1251_general_cs",false],[53,"macroman","macroman_bin",false],[57,"cp1256","cp1256_general_ci",true],[58,"cp1257","cp1257_bin",false],[59,"cp1257","cp1257_general_ci",true],[63,"binary","binary",true],[64,"armscii8","armscii8_bin",false],[65,"ascii","ascii_bin",false],[66,"cp1250","cp1250_bin",false],[67,"cp1256","cp1256_bin",false],[68,"cp866","cp866_bin",false],[69,"dec8","dec8_bin",false],[70,"greek","greek_bin",false],[71,"hebrew","hebrew_bin",false],[72,"hp8","hp8_bin",false],[73,"keybcs2","keybcs2_bin",false],[74,"koi8r","koi8r_bin",false],[75,"koi8u","koi8u_bin",false],[77,"latin2","latin2_bin",false],[78,"latin5","latin5_bin",false],[79,"latin7","latin7_bin",false],[80,"cp850","cp850_bin",false],[81,"cp852","cp852_bin",false],[82,"swe7","swe7_bin",false],[83,"utf8","utf8_bin",false],[84,"big5","big5_bin",false],[85,"euckr","euckr_bin",false],[86,"gb2312","gb2312_bin",false],[87,"gbk","gbk_bin",false],[88,"sjis","sjis_bin",false],[89,"tis620","tis620_bin",false],[90,"ucs2","ucs2_bin",false],[91,"ujis","ujis_bin",false],[92,"geostd8","geostd8_general_ci",true],[93,"geostd8","geostd8_bin",false],[94,"latin1","latin1_spanish_ci",false],[95,"cp932","cp932_japanese_ci",true],[96,"cp932","cp932_bin",false],[97,"eucjpms","eucjpms_japanese_ci",true],[98,"eucjpms","eucjpms_bin",false],[99,"cp1250","cp1250_polish_ci",false],[128,"ucs2","ucs2_unicode_ci",false],[129,"ucs2","ucs2_icelandic_ci",false],[130,"ucs2","ucs2_latvian_ci",false],[131,"ucs2","ucs2_romanian_ci",false],[132,"ucs2","ucs2_slovenian_ci",false],[133,"ucs2","ucs2_polish_ci",false],[134,"ucs2","ucs2_estonian_ci",false],[135,"ucs2","ucs2_spanish_ci",false],[136,"ucs2","ucs2_swedish_ci",false],[137,"ucs2","ucs2_turkish_ci",false],[138,"ucs2","ucs2_czech_ci",false],[139,"ucs2","ucs2_danish_ci",false],[140,"ucs2","ucs2_lithuanian_ci",false],[141,"ucs2","ucs2_slovak_ci",false],[142,"ucs2","ucs2_spanish2_ci",false],[143,"ucs2","ucs2_roman_ci",false],[144,"ucs2","ucs2_persian_ci",false],[145,"ucs2","ucs2_esperanto_ci",false],[146,"ucs2","ucs2_hungarian_ci",false],[192,"utf8","utf8_unicode_ci",false],[193,"utf8","utf8_icelandic_ci",false],[194,"utf8","utf8_latvian_ci",false],[195,"utf8","utf8_romanian_ci",false],[196,"utf8","utf8_slovenian_ci",false],[197,"utf8","utf8_polish_ci",false],[198,"utf8","utf8_estonian_ci",false],[199,"utf8","utf8_spanish_ci",false],[200,"utf8","utf8_swedish_ci",false],[201,"utf8","utf8_turkish_ci",false],[202,"utf8","utf8_czech_ci",false],[203,"utf8","utf8_danish_ci",false],[204,"utf8","utf8_lithuanian_ci",false],[205,"utf8","utf8_slovak_ci",false],[206,"utf8","utf8_spanish2_ci",false],[207,"utf8","utf8_roman_ci",false],[208,"utf8","utf8_persian_ci",false],[209,"utf8","utf8_esperanto_ci",false],[210,"utf8","utf8_hungarian_ci",false],[211,"utf8","utf8_sinhala_ci",false],[224,"utf8mb4","utf8mb4_unicode_ci",false],[225,"utf8mb4","utf8mb4_icelandic_ci",false],[226,"utf8mb4","utf8mb4_latvian_ci",false],[227,"utf8mb4","utf8mb4_romanian_ci",false],[228,"utf8mb4","utf8mb4_slovenian_ci",false],[229,"utf8mb4","utf8mb4_polish_ci",false],[230,"utf8mb4","utf8mb4_estonian_ci",false],[231,"utf8mb4","utf8mb4_spanish_ci",false],[232,"utf8mb4","utf8mb4_swedish_ci",false],[233,"utf8mb4","utf8mb4_turkish_ci",false],[234,"utf8mb4","utf8mb4_czech_ci",false],[235,"utf8mb4","utf8mb4_danish_ci",false],[236,"utf8mb4","utf8mb4_lithuanian_ci",false],[237,"utf8mb4","utf8mb4_slovak_ci",false],[238,"utf8mb4","utf8mb4_spanish2_ci",false],[239,"utf8mb4","utf8mb4_roman_ci",false],[240,"utf8mb4","utf8mb4_persian_ci",false],[241,"utf8mb4","utf8mb4_esperanto_ci",false],[242,"utf8mb4","utf8mb4_hungarian_ci",false],[243,"utf8mb4","utf8mb4_sinhala_ci",false],[254,"utf8","utf8_general_cs",false],]
 
    UNSAFE_CHARSET = [
      "big5", "sjis", "filename", "gbk", "ucs2", "cp932",
    ]

    NUMBER_TO_CHARSET = {}
    COLLATION_TO_CHARSET = {}
    CHARSET_DEFAULT = {}
    CHARSETS.each do |number, csname, clname, default|
      cs = Charset.new number, csname, clname
      cs.unsafe = true if UNSAFE_CHARSET.include? csname
      NUMBER_TO_CHARSET[number] = cs
      COLLATION_TO_CHARSET[clname] = cs
      CHARSET_DEFAULT[csname] = cs if default
    end

    BINARY_CHARSET_NUMBER = CHARSET_DEFAULT['binary'].number

    def self.by_number(n)
      raise ClientError, "unknown charset number: #{n}" unless NUMBER_TO_CHARSET.key? n
      NUMBER_TO_CHARSET[n]
    end

    def self.by_name(str)
      ret = COLLATION_TO_CHARSET[str] || CHARSET_DEFAULT[str]
      raise ClientError, "unknown charset: #{str}" unless ret
      ret
    end

    if defined? Encoding
      CHARSET_ENCODING = { "armscii8"=>nil,"ascii"=>Encoding::US_ASCII,"big5"=>Encoding::Big5,"binary"=>Encoding::ASCII_8BIT,"cp1250"=>Encoding::Windows_1250,"cp1251"=>Encoding::Windows_1251,"cp1256"=>Encoding::Windows_1256,"cp1257"=>Encoding::Windows_1257,"cp850"=>Encoding::CP850,"cp852"=>Encoding::CP852,"cp866"=>Encoding::IBM866,"cp932"=>Encoding::Windows_31J,"dec8"=>nil,"eucjpms"=>Encoding::EucJP_ms,"euckr"=>Encoding::EUC_KR,"gb2312"=>Encoding::EUC_CN,"gbk"=>Encoding::GBK,"geostd8"=>nil,"greek"=>Encoding::ISO_8859_7,"hebrew"=>Encoding::ISO_8859_8,"hp8"=>nil,"keybcs2"=>nil,"koi8r"=>Encoding::KOI8_R,"koi8u"=>Encoding::KOI8_U,"latin1"=>Encoding::ISO_8859_1,"latin2"=>Encoding::ISO_8859_2,"latin5"=>Encoding::ISO_8859_9,"latin7"=>Encoding::ISO_8859_13,"macce"=>Encoding::MacCentEuro,"macroman"=>Encoding::MacRoman,"sjis"=>Encoding::SHIFT_JIS,"swe7"=>nil,"tis620"=>Encoding::TIS_620,"ucs2"=>Encoding::UTF_16BE,"ujis"=>Encoding::EucJP_ms,"utf8"=>Encoding::UTF_8,"utf8mb4"=>Encoding::UTF_8, }      

      def self.to_binary(value)
        value.dup.force_encoding Encoding::ASCII_8BIT
      end

      def self.convert_encoding(raw, encoding)
        raw.dup.force_encoding(encoding).encode
      end

      def encoding
        enc = CHARSET_ENCODING[@name.downcase]
        raise Mysql::ClientError, "unsupported charset: #{@name}" unless enc
        enc
      end
      def convert(value)
        if value.is_a? String and value.encoding != Encoding::ASCII_8BIT
          value = value.encode encoding
        end
        value
      end

    else
      # for Ruby 1.8

      def self.to_binary(value)
        value
      end

      def self.convert_encoding(raw, encoding)
        raw
      end

      def encoding
        nil
      end

      def convert(value)
        value
      end

    end
  end
  
  # Command
  COM_SLEEP=0;COM_QUIT=1;COM_INIT_DB=2;COM_QUERY=3;COM_FIELD_LIST=4;COM_CREATE_DB=5;COM_DROP_DB=6;COM_REFRESH=7;COM_SHUTDOWN=8;COM_STATISTICS=9;COM_PROCESS_INFO=10;COM_CONNECT=11;COM_PROCESS_KILL=12;COM_DEBUG=13;COM_PING=14;COM_TIME=15;COM_DELAYED_INSERT=16;COM_CHANGE_USER=17;COM_BINLOG_DUMP=18;COM_TABLE_DUMP=19;COM_CONNECT_OUT=20;COM_REGISTER_SLAVE=21;COM_STMT_PREPARE=22;COM_STMT_EXECUTE=23;COM_STMT_SEND_LONG_DATA=24;COM_STMT_CLOSE=25;COM_STMT_RESET=26;COM_SET_OPTION=27;COM_STMT_FETCH=28
  # Client flag
  CLIENT_LONG_PASSWORD=1;CLIENT_FOUND_ROWS=1<<1;CLIENT_LONG_FLAG=1<<2;CLIENT_CONNECT_WITH_DB=1<<3;CLIENT_NO_SCHEMA=1<<4;CLIENT_COMPRESS=1<<5;CLIENT_ODBC=1<<6;CLIENT_LOCAL_FILES=1<<7;CLIENT_IGNORE_SPACE=1<<8;CLIENT_PROTOCOL_41=1<<9;CLIENT_INTERACTIVE=1<<10;CLIENT_SSL=1<<11;CLIENT_IGNORE_SIGPIPE=1<<12;CLIENT_TRANSACTIONS=1<<13;CLIENT_RESERVED=1<<14;CLIENT_SECURE_CONNECTION=1<<15;CLIENT_MULTI_STATEMENTS=1<<16;CLIENT_MULTI_RESULTS=1<<17
 

  # Connection Option
  OPT_CONNECT_TIMEOUT=0;OPT_COMPRESS=1;OPT_NAMED_PIPE=2;INIT_COMMAND=3;READ_DEFAULT_FILE=4;READ_DEFAULT_GROUP=5;SET_CHARSET_DIR=6;SET_CHARSET_NAME=7;OPT_LOCAL_INFILE=8;OPT_PROTOCOL=9;SHARED_MEMORY_BASE_NAME=10;OPT_READ_TIMEOUT=11;OPT_WRITE_TIMEOUT=12;OPT_USE_RESULT=13;OPT_USE_REMOTE_CONNECTION=14;OPT_USE_EMBEDDED_CONNECTION=15;OPT_GUESS_CONNECTION=16;SET_CLIENT_IP=17;SECURE_AUTH=18;REPORT_DATA_TRUNCATION=19;OPT_RECONNECT=20;OPT_SSL_VERIFY_SERVER_CERT=21


  # Server Option
  OPTION_MULTI_STATEMENTS_ON  = 0; OPTION_MULTI_STATEMENTS_OFF = 1

  # Server Status
  SERVER_STATUS_IN_TRANS=1;SERVER_STATUS_AUTOCOMMIT=1<<1;SERVER_MORE_RESULTS_EXISTS=1<<3;SERVER_QUERY_NO_GOOD_INDEX_USED=1<<4;SERVER_QUERY_NO_INDEX_USED=1<<5;SERVER_STATUS_CURSOR_EXISTS=1<<6;SERVER_STATUS_LAST_ROW_SENT=1<<7;SERVER_STATUS_DB_DROPPED=1<<8;SERVER_STATUS_NO_BACKSLASH_ESCAPES=1<<9


  # Refresh parameter
  REFRESH_GRANT=1;REFRESH_LOG=1<<1;REFRESH_TABLES=1<<2;REFRESH_HOSTS=1<<3;REFRESH_STATUS=1<<4;REFRESH_THREADS=1<<5;REFRESH_SLAVE=1<<6;REFRESH_MASTER=1<<7;REFRESH_READ_LOCK=1<<14;REFRESH_FAST=1<<15


  class Field
    # Field type
TYPE_DECIMAL=0;TYPE_TINY=1;TYPE_SHORT=2;TYPE_LONG=3;TYPE_FLOAT=4;TYPE_DOUBLE=5;TYPE_NULL=6;TYPE_TIMESTAMP=7;TYPE_LONGLONG=8;TYPE_INT24=9;TYPE_DATE=10;TYPE_TIME=11;TYPE_DATETIME=12;TYPE_YEAR=13;TYPE_NEWDATE=14;TYPE_VARCHAR=15;TYPE_BIT=16;TYPE_NEWDECIMAL=246;TYPE_ENUM=247;TYPE_SET=248;TYPE_TINY_BLOB=249;TYPE_MEDIUM_BLOB=250;TYPE_LONG_BLOB=251;TYPE_BLOB=252;TYPE_VAR_STRING=253;TYPE_STRING=254;TYPE_GEOMETRY=255;TYPE_CHAR=TYPE_TINY;TYPE_INTERVAL=TYPE_ENUM

    # Flag
NOT_NULL_FLAG=1;PRI_KEY_FLAG=2;UNIQUE_KEY_FLAG=4;MULTIPLE_KEY_FLAG=8;BLOB_FLAG=16;UNSIGNED_FLAG=32;ZEROFILL_FLAG=64;BINARY_FLAG=128;ENUM_FLAG=256;AUTO_INCREMENT_FLAG=512;TIMESTAMP_FLAG=1024;SET_FLAG=2048;NUM_FLAG=32768;PART_KEY_FLAG=16384;GROUP_FLAG=32768;UNIQUE_FLAG=65536;BINCMP_FLAG=131072
  end

  class Stmt
    # Cursor type
    CURSOR_TYPE_NO_CURSOR = 0;CURSOR_TYPE_READ_ONLY = 1
  end
  
  
  class Error < StandardError
    ERRNO = 0

    def self.define_error_class(prefix_re)
      self.constants.each do |errname|
        errname = errname.to_s
        next unless errname =~ prefix_re
        errno = self.const_get errname
        excname = errname.sub(prefix_re,'').gsub(/(\A.|_.)([A-Z]+)/){$1+$2.downcase}.gsub(/_/,'')
        klass = Class.new self
        klass.const_set 'ERRNO', errno
        self.const_set excname, klass
        self::ERROR_MAP[errno] = klass
        Mysql::Error.const_set errname, errno
      end
    end

    attr_reader :sqlstate, :error

    def initialize(message, sqlstate='HY000')
      @sqlstate = sqlstate
      @error = message
      super message
    end

    def errno
      self.class::ERRNO
    end
  end

  # server side error
  class ServerError < Error
    ERROR_MAP = {}

ER_HASHCHK=1000;ER_NISAMCHK=1001;ER_NO=1002;ER_YES=1003;ER_CANT_CREATE_FILE=1004;ER_CANT_CREATE_TABLE=1005;ER_CANT_CREATE_DB=1006;ER_DB_CREATE_EXISTS=1007;ER_DB_DROP_EXISTS=1008;ER_DB_DROP_DELETE=1009;ER_DB_DROP_RMDIR=1010;ER_CANT_DELETE_FILE=1011;ER_CANT_FIND_SYSTEM_REC=1012;ER_CANT_GET_STAT=1013;ER_CANT_GET_WD=1014;ER_CANT_LOCK=1015;ER_CANT_OPEN_FILE=1016;ER_FILE_NOT_FOUND=1017;ER_CANT_READ_DIR=1018;ER_CANT_SET_WD=1019;ER_CHECKREAD=1020;ER_DISK_FULL=1021;ER_DUP_KEY=1022;ER_ERROR_ON_CLOSE=1023;ER_ERROR_ON_READ=1024;ER_ERROR_ON_RENAME=1025;ER_ERROR_ON_WRITE=1026;ER_FILE_USED=1027;ER_FILSORT_ABORT=1028;ER_FORM_NOT_FOUND=1029;ER_GET_ERRNO=1030;ER_ILLEGAL_HA=1031;ER_KEY_NOT_FOUND=1032;ER_NOT_FORM_FILE=1033;ER_NOT_KEYFILE=1034;ER_OLD_KEYFILE=1035;ER_OPEN_AS_READONLY=1036;ER_OUTOFMEMORY=1037;ER_OUT_OF_SORTMEMORY=1038;ER_UNEXPECTED_EOF=1039;ER_CON_COUNT_ERROR=1040;ER_OUT_OF_RESOURCES=1041;ER_BAD_HOST_ERROR=1042;ER_HANDSHAKE_ERROR=1043;ER_DBACCESS_DENIED_ERROR=1044;ER_ACCESS_DENIED_ERROR=1045;ER_NO_DB_ERROR=1046;ER_UNKNOWN_COM_ERROR=1047;ER_BAD_NULL_ERROR=1048;ER_BAD_DB_ERROR=1049;ER_TABLE_EXISTS_ERROR=1050;ER_BAD_TABLE_ERROR=1051;ER_NON_UNIQ_ERROR=1052;ER_SERVER_SHUTDOWN=1053;ER_BAD_FIELD_ERROR=1054;ER_WRONG_FIELD_WITH_GROUP=1055;ER_WRONG_GROUP_FIELD=1056;ER_WRONG_SUM_SELECT=1057;ER_WRONG_VALUE_COUNT=1058;ER_TOO_LONG_IDENT=1059;ER_DUP_FIELDNAME=1060;ER_DUP_KEYNAME=1061;ER_DUP_ENTRY=1062;ER_WRONG_FIELD_SPEC=1063;ER_PARSE_ERROR=1064;ER_EMPTY_QUERY=1065;ER_NONUNIQ_TABLE=1066;ER_INVALID_DEFAULT=1067;ER_MULTIPLE_PRI_KEY=1068;ER_TOO_MANY_KEYS=1069;ER_TOO_MANY_KEY_PARTS=1070;ER_TOO_LONG_KEY=1071;ER_KEY_COLUMN_DOES_NOT_EXITS=1072;ER_BLOB_USED_AS_KEY=1073;ER_TOO_BIG_FIELDLENGTH=1074;ER_WRONG_AUTO_KEY=1075;ER_READY=1076;ER_NORMAL_SHUTDOWN=1077;ER_GOT_SIGNAL=1078;ER_SHUTDOWN_COMPLETE=1079;ER_FORCING_CLOSE=1080;ER_IPSOCK_ERROR=1081;ER_NO_SUCH_INDEX=1082;ER_WRONG_FIELD_TERMINATORS=1083;ER_BLOBS_AND_NO_TERMINATED=1084;ER_TEXTFILE_NOT_READABLE=1085;ER_FILE_EXISTS_ERROR=1086;ER_LOAD_INFO=1087;ER_ALTER_INFO=1088;ER_WRONG_SUB_KEY=1089;ER_CANT_REMOVE_ALL_FIELDS=1090;ER_CANT_DROP_FIELD_OR_KEY=1091;ER_INSERT_INFO=1092;ER_UPDATE_TABLE_USED=1093;ER_NO_SUCH_THREAD=1094;ER_KILL_DENIED_ERROR=1095;ER_NO_TABLES_USED=1096;ER_TOO_BIG_SET=1097;ER_NO_UNIQUE_LOGFILE=1098;ER_TABLE_NOT_LOCKED_FOR_WRITE=1099;ER_TABLE_NOT_LOCKED=1100;ER_BLOB_CANT_HAVE_DEFAULT=1101;ER_WRONG_DB_NAME=1102;ER_WRONG_TABLE_NAME=1103;ER_TOO_BIG_SELECT=1104;ER_UNKNOWN_ERROR=1105;ER_UNKNOWN_PROCEDURE=1106;ER_WRONG_PARAMCOUNT_TO_PROCEDURE=1107;ER_WRONG_PARAMETERS_TO_PROCEDURE=1108;ER_UNKNOWN_TABLE=1109;ER_FIELD_SPECIFIED_TWICE=1110;ER_INVALID_GROUP_FUNC_USE=1111;ER_UNSUPPORTED_EXTENSION=1112;ER_TABLE_MUST_HAVE_COLUMNS=1113;ER_RECORD_FILE_FULL=1114;ER_UNKNOWN_CHARACTER_SET=1115;ER_TOO_MANY_TABLES=1116;ER_TOO_MANY_FIELDS=1117;ER_TOO_BIG_ROWSIZE=1118;ER_STACK_OVERRUN=1119;ER_WRONG_OUTER_JOIN=1120;ER_NULL_COLUMN_IN_INDEX=1121;ER_CANT_FIND_UDF=1122;ER_CANT_INITIALIZE_UDF=1123;ER_UDF_NO_PATHS=1124;ER_UDF_EXISTS=1125;ER_CANT_OPEN_LIBRARY=1126;ER_CANT_FIND_DL_ENTRY=1127;ER_FUNCTION_NOT_DEFINED=1128;ER_HOST_IS_BLOCKED=1129;ER_HOST_NOT_PRIVILEGED=1130;ER_PASSWORD_ANONYMOUS_USER=1131;ER_PASSWORD_NOT_ALLOWED=1132;ER_PASSWORD_NO_MATCH=1133;ER_UPDATE_INFO=1134;ER_CANT_CREATE_THREAD=1135;ER_WRONG_VALUE_COUNT_ON_ROW=1136;ER_CANT_REOPEN_TABLE=1137;ER_INVALID_USE_OF_NULL=1138;ER_REGEXP_ERROR=1139;ER_MIX_OF_GROUP_FUNC_AND_FIELDS=1140;ER_NONEXISTING_GRANT=1141;ER_TABLEACCESS_DENIED_ERROR=1142;ER_COLUMNACCESS_DENIED_ERROR=1143;ER_ILLEGAL_GRANT_FOR_TABLE=1144;ER_GRANT_WRONG_HOST_OR_USER=1145;ER_NO_SUCH_TABLE=1146;ER_NONEXISTING_TABLE_GRANT=1147;ER_NOT_ALLOWED_COMMAND=1148;ER_SYNTAX_ERROR=1149;ER_DELAYED_CANT_CHANGE_LOCK=1150;ER_TOO_MANY_DELAYED_THREADS=1151;ER_ABORTING_CONNECTION=1152;ER_NET_PACKET_TOO_LARGE=1153;ER_NET_READ_ERROR_FROM_PIPE=1154;ER_NET_FCNTL_ERROR=1155;ER_NET_PACKETS_OUT_OF_ORDER=1156;ER_NET_UNCOMPRESS_ERROR=1157;ER_NET_READ_ERROR=1158;ER_NET_READ_INTERRUPTED=1159;ER_NET_ERROR_ON_WRITE=1160;ER_NET_WRITE_INTERRUPTED=1161;ER_TOO_LONG_STRING=1162;ER_TABLE_CANT_HANDLE_BLOB=1163;ER_TABLE_CANT_HANDLE_AUTO_INCREMENT=1164;ER_DELAYED_INSERT_TABLE_LOCKED=1165;ER_WRONG_COLUMN_NAME=1166;ER_WRONG_KEY_COLUMN=1167;ER_WRONG_MRG_TABLE=1168;ER_DUP_UNIQUE=1169;ER_BLOB_KEY_WITHOUT_LENGTH=1170;ER_PRIMARY_CANT_HAVE_NULL=1171;ER_TOO_MANY_ROWS=1172;ER_REQUIRES_PRIMARY_KEY=1173;ER_NO_RAID_COMPILED=1174;ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE=1175;ER_KEY_DOES_NOT_EXITS=1176;ER_CHECK_NO_SUCH_TABLE=1177;ER_CHECK_NOT_IMPLEMENTED=1178;ER_CANT_DO_THIS_DURING_AN_TRANSACTION=1179;ER_ERROR_DURING_COMMIT=1180;ER_ERROR_DURING_ROLLBACK=1181;ER_ERROR_DURING_FLUSH_LOGS=1182;ER_ERROR_DURING_CHECKPOINT=1183;ER_NEW_ABORTING_CONNECTION=1184;ER_DUMP_NOT_IMPLEMENTED=1185;ER_FLUSH_MASTER_BINLOG_CLOSED=1186;ER_INDEX_REBUILD=1187;ER_MASTER=1188;ER_MASTER_NET_READ=1189;ER_MASTER_NET_WRITE=1190;ER_FT_MATCHING_KEY_NOT_FOUND=1191;ER_LOCK_OR_ACTIVE_TRANSACTION=1192;ER_UNKNOWN_SYSTEM_VARIABLE=1193;ER_CRASHED_ON_USAGE=1194;ER_CRASHED_ON_REPAIR=1195;ER_WARNING_NOT_COMPLETE_ROLLBACK=1196;ER_TRANS_CACHE_FULL=1197;ER_SLAVE_MUST_STOP=1198;ER_SLAVE_NOT_RUNNING=1199;ER_BAD_SLAVE=1200;ER_MASTER_INFO=1201;ER_SLAVE_THREAD=1202;ER_TOO_MANY_USER_CONNECTIONS=1203;ER_SET_CONSTANTS_ONLY=1204;ER_LOCK_WAIT_TIMEOUT=1205;ER_LOCK_TABLE_FULL=1206;ER_READ_ONLY_TRANSACTION=1207;ER_DROP_DB_WITH_READ_LOCK=1208;ER_CREATE_DB_WITH_READ_LOCK=1209;ER_WRONG_ARGUMENTS=1210;ER_NO_PERMISSION_TO_CREATE_USER=1211;ER_UNION_TABLES_IN_DIFFERENT_DIR=1212;ER_LOCK_DEADLOCK=1213;ER_TABLE_CANT_HANDLE_FT=1214;ER_CANNOT_ADD_FOREIGN=1215;ER_NO_REFERENCED_ROW=1216;ER_ROW_IS_REFERENCED=1217;ER_CONNECT_TO_MASTER=1218;ER_QUERY_ON_MASTER=1219;ER_ERROR_WHEN_EXECUTING_COMMAND=1220;ER_WRONG_USAGE=1221;ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT=1222;ER_CANT_UPDATE_WITH_READLOCK=1223;ER_MIXING_NOT_ALLOWED=1224;ER_DUP_ARGUMENT=1225;ER_USER_LIMIT_REACHED=1226;ER_SPECIFIC_ACCESS_DENIED_ERROR=1227;ER_LOCAL_VARIABLE=1228;ER_GLOBAL_VARIABLE=1229;ER_NO_DEFAULT=1230;ER_WRONG_VALUE_FOR_VAR=1231;ER_WRONG_TYPE_FOR_VAR=1232;ER_VAR_CANT_BE_READ=1233;ER_CANT_USE_OPTION_HERE=1234;ER_NOT_SUPPORTED_YET=1235;ER_MASTER_FATAL_ERROR_READING_BINLOG=1236;ER_SLAVE_IGNORED_TABLE=1237;ER_INCORRECT_GLOBAL_LOCAL_VAR=1238;ER_WRONG_FK_DEF=1239;ER_KEY_REF_DO_NOT_MATCH_TABLE_REF=1240;ER_OPERAND_COLUMNS=1241;ER_SUBQUERY_NO_1_ROW=1242;ER_UNKNOWN_STMT_HANDLER=1243;ER_CORRUPT_HELP_DB=1244;ER_CYCLIC_REFERENCE=1245;ER_AUTO_CONVERT=1246;ER_ILLEGAL_REFERENCE=1247;ER_DERIVED_MUST_HAVE_ALIAS=1248;ER_SELECT_REDUCED=1249;ER_TABLENAME_NOT_ALLOWED_HERE=1250;ER_NOT_SUPPORTED_AUTH_MODE=1251;ER_SPATIAL_CANT_HAVE_NULL=1252;ER_COLLATION_CHARSET_MISMATCH=1253;ER_SLAVE_WAS_RUNNING=1254;ER_SLAVE_WAS_NOT_RUNNING=1255;ER_TOO_BIG_FOR_UNCOMPRESS=1256;ER_ZLIB_Z_MEM_ERROR=1257;ER_ZLIB_Z_BUF_ERROR=1258;ER_ZLIB_Z_DATA_ERROR=1259;ER_CUT_VALUE_GROUP_CONCAT=1260;ER_WARN_TOO_FEW_RECORDS=1261;ER_WARN_TOO_MANY_RECORDS=1262;ER_WARN_NULL_TO_NOTNULL=1263;ER_WARN_DATA_OUT_OF_RANGE=1264;WARN_DATA_TRUNCATED=1265;ER_WARN_USING_OTHER_HANDLER=1266;ER_CANT_AGGREGATE_2COLLATIONS=1267;ER_DROP_USER=1268;ER_REVOKE_GRANTS=1269;ER_CANT_AGGREGATE_3COLLATIONS=1270;ER_CANT_AGGREGATE_NCOLLATIONS=1271;ER_VARIABLE_IS_NOT_STRUCT=1272;ER_UNKNOWN_COLLATION=1273;ER_SLAVE_IGNORED_SSL_PARAMS=1274;ER_SERVER_IS_IN_SECURE_AUTH_MODE=1275;ER_WARN_FIELD_RESOLVED=1276;ER_BAD_SLAVE_UNTIL_COND=1277;ER_MISSING_SKIP_SLAVE=1278;ER_UNTIL_COND_IGNORED=1279;ER_WRONG_NAME_FOR_INDEX=1280;ER_WRONG_NAME_FOR_CATALOG=1281;ER_WARN_QC_RESIZE=1282;ER_BAD_FT_COLUMN=1283;ER_UNKNOWN_KEY_CACHE=1284;ER_WARN_HOSTNAME_WONT_WORK=1285;ER_UNKNOWN_STORAGE_ENGINE=1286;ER_WARN_DEPRECATED_SYNTAX=1287;ER_NON_UPDATABLE_TABLE=1288;ER_FEATURE_DISABLED=1289;ER_OPTION_PREVENTS_STATEMENT=1290;ER_DUPLICATED_VALUE_IN_TYPE=1291;ER_TRUNCATED_WRONG_VALUE=1292;ER_TOO_MUCH_AUTO_TIMESTAMP_COLS=1293;ER_INVALID_ON_UPDATE=1294;ER_UNSUPPORTED_PS=1295;ER_GET_ERRMSG=1296;ER_GET_TEMPORARY_ERRMSG=1297;ER_UNKNOWN_TIME_ZONE=1298;ER_WARN_INVALID_TIMESTAMP=1299;ER_INVALID_CHARACTER_STRING=1300;ER_WARN_ALLOWED_PACKET_OVERFLOWED=1301;ER_CONFLICTING_DECLARATIONS=1302;ER_SP_NO_RECURSIVE_CREATE=1303;ER_SP_ALREADY_EXISTS=1304;ER_SP_DOES_NOT_EXIST=1305;ER_SP_DROP_FAILED=1306;ER_SP_STORE_FAILED=1307;ER_SP_LILABEL_MISMATCH=1308;ER_SP_LABEL_REDEFINE=1309;ER_SP_LABEL_MISMATCH=1310;ER_SP_UNINIT_VAR=1311;ER_SP_BADSELECT=1312;ER_SP_BADRETURN=1313;ER_SP_BADSTATEMENT=1314;ER_UPDATE_LOG_DEPRECATED_IGNORED=1315;ER_UPDATE_LOG_DEPRECATED_TRANSLATED=1316;ER_QUERY_INTERRUPTED=1317;ER_SP_WRONG_NO_OF_ARGS=1318;ER_SP_COND_MISMATCH=1319;ER_SP_NORETURN=1320;ER_SP_NORETURNEND=1321;ER_SP_BAD_CURSOR_QUERY=1322;ER_SP_BAD_CURSOR_SELECT=1323;ER_SP_CURSOR_MISMATCH=1324;ER_SP_CURSOR_ALREADY_OPEN=1325;ER_SP_CURSOR_NOT_OPEN=1326;ER_SP_UNDECLARED_VAR=1327;ER_SP_WRONG_NO_OF_FETCH_ARGS=1328;ER_SP_FETCH_NO_DATA=1329;ER_SP_DUP_PARAM=1330;ER_SP_DUP_VAR=1331;ER_SP_DUP_COND=1332;ER_SP_DUP_CURS=1333;ER_SP_CANT_ALTER=1334;ER_SP_SUBSELECT_NYI=1335;ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG=1336;ER_SP_VARCOND_AFTER_CURSHNDLR=1337;ER_SP_CURSOR_AFTER_HANDLER=1338;ER_SP_CASE_NOT_FOUND=1339;ER_FPARSER_TOO_BIG_FILE=1340;ER_FPARSER_BAD_HEADER=1341;ER_FPARSER_EOF_IN_COMMENT=1342;ER_FPARSER_ERROR_IN_PARAMETER=1343;ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER=1344;ER_VIEW_NO_EXPLAIN=1345;ER_FRM_UNKNOWN_TYPE=1346;ER_WRONG_OBJECT=1347;ER_NONUPDATEABLE_COLUMN=1348;ER_VIEW_SELECT_DERIVED=1349;ER_VIEW_SELECT_CLAUSE=1350;ER_VIEW_SELECT_VARIABLE=1351;ER_VIEW_SELECT_TMPTABLE=1352;ER_VIEW_WRONG_LIST=1353;ER_WARN_VIEW_MERGE=1354;ER_WARN_VIEW_WITHOUT_KEY=1355;ER_VIEW_INVALID=1356;ER_SP_NO_DROP_SP=1357;ER_SP_GOTO_IN_HNDLR=1358;ER_TRG_ALREADY_EXISTS=1359;ER_TRG_DOES_NOT_EXIST=1360;ER_TRG_ON_VIEW_OR_TEMP_TABLE=1361;ER_TRG_CANT_CHANGE_ROW=1362;ER_TRG_NO_SUCH_ROW_IN_TRG=1363;ER_NO_DEFAULT_FOR_FIELD=1364;ER_DIVISION_BY_ZERO=1365;ER_TRUNCATED_WRONG_VALUE_FOR_FIELD=1366;ER_ILLEGAL_VALUE_FOR_TYPE=1367;ER_VIEW_NONUPD_CHECK=1368;ER_VIEW_CHECK_FAILED=1369;ER_PROCACCESS_DENIED_ERROR=1370;ER_RELAY_LOG_FAIL=1371;ER_PASSWD_LENGTH=1372;ER_UNKNOWN_TARGET_BINLOG=1373;ER_IO_ERR_LOG_INDEX_READ=1374;ER_BINLOG_PURGE_PROHIBITED=1375;ER_FSEEK_FAIL=1376;ER_BINLOG_PURGE_FATAL_ERR=1377;ER_LOG_IN_USE=1378;ER_LOG_PURGE_UNKNOWN_ERR=1379;ER_RELAY_LOG_INIT=1380;ER_NO_BINARY_LOGGING=1381;ER_RESERVED_SYNTAX=1382;ER_WSAS_FAILED=1383;ER_DIFF_GROUPS_PROC=1384;ER_NO_GROUP_FOR_PROC=1385;ER_ORDER_WITH_PROC=1386;ER_LOGGING_PROHIBIT_CHANGING_OF=1387;ER_NO_FILE_MAPPING=1388;ER_WRONG_MAGIC=1389;ER_PS_MANY_PARAM=1390;ER_KEY_PART_0=1391;ER_VIEW_CHECKSUM=1392;ER_VIEW_MULTIUPDATE=1393;ER_VIEW_NO_INSERT_FIELD_LIST=1394;ER_VIEW_DELETE_MERGE_VIEW=1395;ER_CANNOT_USER=1396;ER_XAER_NOTA=1397;ER_XAER_INVAL=1398;ER_XAER_RMFAIL=1399;ER_XAER_OUTSIDE=1400;ER_XAER_RMERR=1401;ER_XA_RBROLLBACK=1402;ER_NONEXISTING_PROC_GRANT=1403;ER_PROC_AUTO_GRANT_FAIL=1404;ER_PROC_AUTO_REVOKE_FAIL=1405;ER_DATA_TOO_LONG=1406;ER_SP_BAD_SQLSTATE=1407;ER_STARTUP=1408;ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR=1409;ER_CANT_CREATE_USER_WITH_GRANT=1410;ER_WRONG_VALUE_FOR_TYPE=1411;ER_TABLE_DEF_CHANGED=1412;ER_SP_DUP_HANDLER=1413;ER_SP_NOT_VAR_ARG=1414;ER_SP_NO_RETSET=1415;ER_CANT_CREATE_GEOMETRY_OBJECT=1416;ER_FAILED_ROUTINE_BREAK_BINLOG=1417;ER_BINLOG_UNSAFE_ROUTINE=1418;ER_BINLOG_CREATE_ROUTINE_NEED_SUPER=1419;ER_EXEC_STMT_WITH_OPEN_CURSOR=1420;ER_STMT_HAS_NO_OPEN_CURSOR=1421;ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG=1422;ER_NO_DEFAULT_FOR_VIEW_FIELD=1423;ER_SP_NO_RECURSION=1424;ER_TOO_BIG_SCALE=1425;ER_TOO_BIG_PRECISION=1426;ER_M_BIGGER_THAN_D=1427;ER_WRONG_LOCK_OF_SYSTEM_TABLE=1428;ER_CONNECT_TO_FOREIGN_DATA_SOURCE=1429;ER_QUERY_ON_FOREIGN_DATA_SOURCE=1430;ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST=1431;ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE=1432;ER_FOREIGN_DATA_STRING_INVALID=1433;ER_CANT_CREATE_FEDERATED_TABLE=1434;ER_TRG_IN_WRONG_SCHEMA=1435;ER_STACK_OVERRUN_NEED_MORE=1436;ER_TOO_LONG_BODY=1437;ER_WARN_CANT_DROP_DEFAULT_KEYCACHE=1438;ER_TOO_BIG_DISPLAYWIDTH=1439;ER_XAER_DUPID=1440;ER_DATETIME_FUNCTION_OVERFLOW=1441;ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG=1442;ER_VIEW_PREVENT_UPDATE=1443;ER_PS_NO_RECURSION=1444;ER_SP_CANT_SET_AUTOCOMMIT=1445;ER_MALFORMED_DEFINER=1446;ER_VIEW_FRM_NO_USER=1447;ER_VIEW_OTHER_USER=1448;ER_NO_SUCH_USER=1449;ER_FORBID_SCHEMA_CHANGE=1450;ER_ROW_IS_REFERENCED_2=1451;ER_NO_REFERENCED_ROW_2=1452;ER_SP_BAD_VAR_SHADOW=1453;ER_TRG_NO_DEFINER=1454;ER_OLD_FILE_FORMAT=1455;ER_SP_RECURSION_LIMIT=1456;ER_SP_PROC_TABLE_CORRUPT=1457;ER_SP_WRONG_NAME=1458;ER_TABLE_NEEDS_UPGRADE=1459;ER_SP_NO_AGGREGATE=1460;ER_MAX_PREPARED_STMT_COUNT_REACHED=1461;ER_VIEW_RECURSIVE=1462;ER_NON_GROUPING_FIELD_USED=1463;ER_TABLE_CANT_HANDLE_SPKEYS=1464;ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA=1465;ER_REMOVED_SPACES=1466;ER_AUTOINC_READ_FAILED=1467;ER_USERNAME=1468;ER_HOSTNAME=1469;ER_WRONG_STRING_LENGTH=1470;ER_NON_INSERTABLE_TABLE=1471;ER_ADMIN_WRONG_MRG_TABLE=1472;ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT=1473;ER_NAME_BECOMES_EMPTY=1474;ER_AMBIGUOUS_FIELD_TERM=1475;ER_FOREIGN_SERVER_EXISTS=1476;ER_FOREIGN_SERVER_DOESNT_EXIST=1477;ER_ILLEGAL_HA_CREATE_OPTION=1478;ER_PARTITION_REQUIRES_VALUES_ERROR=1479;ER_PARTITION_WRONG_VALUES_ERROR=1480;ER_PARTITION_MAXVALUE_ERROR=1481;ER_PARTITION_SUBPARTITION_ERROR=1482;ER_PARTITION_SUBPART_MIX_ERROR=1483;ER_PARTITION_WRONG_NO_PART_ERROR=1484;ER_PARTITION_WRONG_NO_SUBPART_ERROR=1485;ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR=1486;ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR=1487;ER_FIELD_NOT_FOUND_PART_ERROR=1488;ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR=1489;ER_INCONSISTENT_PARTITION_INFO_ERROR=1490;ER_PARTITION_FUNC_NOT_ALLOWED_ERROR=1491;ER_PARTITIONS_MUST_BE_DEFINED_ERROR=1492;ER_RANGE_NOT_INCREASING_ERROR=1493;ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR=1494;ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR=1495;ER_PARTITION_ENTRY_ERROR=1496;ER_MIX_HANDLER_ERROR=1497;ER_PARTITION_NOT_DEFINED_ERROR=1498;ER_TOO_MANY_PARTITIONS_ERROR=1499;ER_SUBPARTITION_ERROR=1500;ER_CANT_CREATE_HANDLER_FILE=1501;ER_BLOB_FIELD_IN_PART_FUNC_ERROR=1502;ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF=1503;ER_NO_PARTS_ERROR=1504;ER_PARTITION_MGMT_ON_NONPARTITIONED=1505;ER_FOREIGN_KEY_ON_PARTITIONED=1506;ER_DROP_PARTITION_NON_EXISTENT=1507;ER_DROP_LAST_PARTITION=1508;ER_COALESCE_ONLY_ON_HASH_PARTITION=1509;ER_REORG_HASH_ONLY_ON_SAME_NO=1510;ER_REORG_NO_PARAM_ERROR=1511;ER_ONLY_ON_RANGE_LIST_PARTITION=1512;ER_ADD_PARTITION_SUBPART_ERROR=1513;ER_ADD_PARTITION_NO_NEW_PARTITION=1514;ER_COALESCE_PARTITION_NO_PARTITION=1515;ER_REORG_PARTITION_NOT_EXIST=1516;ER_SAME_NAME_PARTITION=1517;ER_NO_BINLOG_ERROR=1518;ER_CONSECUTIVE_REORG_PARTITIONS=1519;ER_REORG_OUTSIDE_RANGE=1520;ER_PARTITION_FUNCTION_FAILURE=1521;ER_PART_STATE_ERROR=1522;ER_LIMITED_PART_RANGE=1523;ER_PLUGIN_IS_NOT_LOADED=1524;ER_WRONG_VALUE=1525;ER_NO_PARTITION_FOR_GIVEN_VALUE=1526;ER_FILEGROUP_OPTION_ONLY_ONCE=1527;ER_CREATE_FILEGROUP_FAILED=1528;ER_DROP_FILEGROUP_FAILED=1529;ER_TABLESPACE_AUTO_EXTEND_ERROR=1530;ER_WRONG_SIZE_NUMBER=1531;ER_SIZE_OVERFLOW_ERROR=1532;ER_ALTER_FILEGROUP_FAILED=1533;ER_BINLOG_ROW_LOGGING_FAILED=1534;ER_BINLOG_ROW_WRONG_TABLE_DEF=1535;ER_BINLOG_ROW_RBR_TO_SBR=1536;ER_EVENT_ALREADY_EXISTS=1537;ER_EVENT_STORE_FAILED=1538;ER_EVENT_DOES_NOT_EXIST=1539;ER_EVENT_CANT_ALTER=1540;ER_EVENT_DROP_FAILED=1541;ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG=1542;ER_EVENT_ENDS_BEFORE_STARTS=1543;ER_EVENT_EXEC_TIME_IN_THE_PAST=1544;ER_EVENT_OPEN_TABLE_FAILED=1545;ER_EVENT_NEITHER_M_EXPR_NOR_M_AT=1546;ER_COL_COUNT_DOESNT_MATCH_CORRUPTED=1547;ER_CANNOT_LOAD_FROM_TABLE=1548;ER_EVENT_CANNOT_DELETE=1549;ER_EVENT_COMPILE_ERROR=1550;ER_EVENT_SAME_NAME=1551;ER_EVENT_DATA_TOO_LONG=1552;ER_DROP_INDEX_FK=1553;ER_WARN_DEPRECATED_SYNTAX_WITH_VER=1554;ER_CANT_WRITE_LOCK_LOG_TABLE=1555;ER_CANT_LOCK_LOG_TABLE=1556;ER_FOREIGN_DUPLICATE_KEY=1557;ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE=1558;ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR=1559;ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT=1560;ER_NDB_CANT_SWITCH_BINLOG_FORMAT=1561;ER_PARTITION_NO_TEMPORARY=1562;ER_PARTITION_CONST_DOMAIN_ERROR=1563;ER_PARTITION_FUNCTION_IS_NOT_ALLOWED=1564;ER_DDL_LOG_ERROR=1565;ER_NULL_IN_VALUES_LESS_THAN=1566;ER_WRONG_PARTITION_NAME=1567;ER_CANT_CHANGE_TX_ISOLATION=1568;ER_DUP_ENTRY_AUTOINCREMENT_CASE=1569;ER_EVENT_MODIFY_QUEUE_ERROR=1570;ER_EVENT_SET_VAR_ERROR=1571;ER_PARTITION_MERGE_ERROR=1572;ER_CANT_ACTIVATE_LOG=1573;ER_RBR_NOT_AVAILABLE=1574;ER_BASE64_DECODE_ERROR=1575;ER_EVENT_RECURSION_FORBIDDEN=1576;ER_EVENTS_DB_ERROR=1577;ER_ONLY_INTEGERS_ALLOWED=1578;ER_UNSUPORTED_LOG_ENGINE=1579;ER_BAD_LOG_STATEMENT=1580;ER_CANT_RENAME_LOG_TABLE=1581;ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT=1582;ER_WRONG_PARAMETERS_TO_NATIVE_FCT=1583;ER_WRONG_PARAMETERS_TO_STORED_FCT=1584;ER_NATIVE_FCT_NAME_COLLISION=1585;ER_DUP_ENTRY_WITH_KEY_NAME=1586;ER_BINLOG_PURGE_EMFILE=1587;ER_EVENT_CANNOT_CREATE_IN_THE_PAST=1588;ER_EVENT_CANNOT_ALTER_IN_THE_PAST=1589;ER_SLAVE_INCIDENT=1590;ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT=1591;ER_BINLOG_UNSAFE_STATEMENT=1592;ER_SLAVE_FATAL_ERROR=1593;ER_SLAVE_RELAY_LOG_READ_FAILURE=1594;ER_SLAVE_RELAY_LOG_WRITE_FAILURE=1595;ER_SLAVE_CREATE_EVENT_FAILURE=1596;ER_SLAVE_MASTER_COM_FAILURE=1597;ER_BINLOG_LOGGING_IMPOSSIBLE=1598;ER_VIEW_NO_CREATION_CTX=1599;ER_VIEW_INVALID_CREATION_CTX=1600;ER_SR_INVALID_CREATION_CTX=1601;ER_TRG_CORRUPTED_FILE=1602;ER_TRG_NO_CREATION_CTX=1603;ER_TRG_INVALID_CREATION_CTX=1604;ER_EVENT_INVALID_CREATION_CTX=1605;ER_TRG_CANT_OPEN_TABLE=1606;ER_CANT_CREATE_SROUTINE=1607;ER_NEVER_USED=1608;ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT=1609;ER_SLAVE_CORRUPT_EVENT=1610;ER_LOAD_DATA_INVALID_COLUMN=1611;ER_LOG_PURGE_NO_FILE=1612;ER_XA_RBTIMEOUT=1613;ER_XA_RBDEADLOCK=1614;ER_NEED_REPREPARE=1615;ER_DELAYED_NOT_SUPPORTED=1616;WARN_NO_MASTER_INFO=1617;WARN_OPTION_IGNORED=1618;WARN_PLUGIN_DELETE_BUILTIN=1619;WARN_PLUGIN_BUSY=1620;ER_VARIABLE_IS_READONLY=1621;ER_WARN_ENGINE_TRANSACTION_ROLLBACK=1622;ER_SLAVE_HEARTBEAT_FAILURE=1623;ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE=1624;ER_NDB_REPLICATION_SCHEMA_ERROR=1625;ER_CONFLICT_FN_PARSE_ERROR=1626;ER_EXCEPTIONS_WRITE_ERROR=1627;ER_TOO_LONG_TABLE_COMMENT=1628;ER_TOO_LONG_FIELD_COMMENT=1629;ER_FUNC_INEXISTENT_NAME_COLLISION=1630;ER_DATABASE_NAME=1631;ER_TABLE_NAME=1632;ER_PARTITION_NAME=1633;ER_SUBPARTITION_NAME=1634;ER_TEMPORARY_NAME=1635;ER_RENAMED_NAME=1636;ER_TOO_MANY_CONCURRENT_TRXS=1637;WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED=1638;ER_DEBUG_SYNC_TIMEOUT=1639;ER_DEBUG_SYNC_HIT_LIMIT=1640;ER_DUP_SIGNAL_SET=1641;ER_SIGNAL_WARN=1642;ER_SIGNAL_NOT_FOUND=1643;ER_SIGNAL_EXCEPTION=1644;ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER=1645;ER_SIGNAL_BAD_CONDITION_TYPE=1646;WARN_COND_ITEM_TRUNCATED=1647;ER_COND_ITEM_TOO_LONG=1648;ER_UNKNOWN_LOCALE=1649;ER_SLAVE_IGNORE_SERVER_IDS=1650;ER_QUERY_CACHE_DISABLED=1651;ER_SAME_NAME_PARTITION_FIELD=1652;ER_PARTITION_COLUMN_LIST_ERROR=1653;ER_WRONG_TYPE_COLUMN_VALUE_ERROR=1654;ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR=1655;ER_MAXVALUE_IN_VALUES_IN=1656;ER_TOO_MANY_VALUES_ERROR=1657;ER_ROW_SINGLE_PARTITION_FIELD_ERROR=1658;ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD=1659;ER_PARTITION_FIELDS_TOO_LONG=1660;ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE=1661;ER_BINLOG_ROW_MODE_AND_STMT_ENGINE=1662;ER_BINLOG_UNSAFE_AND_STMT_ENGINE=1663;ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE=1664;ER_BINLOG_STMT_MODE_AND_ROW_ENGINE=1665;ER_BINLOG_ROW_INJECTION_AND_STMT_MODE=1666;ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE=1667;ER_BINLOG_UNSAFE_LIMIT=1668;ER_BINLOG_UNSAFE_INSERT_DELAYED=1669;ER_BINLOG_UNSAFE_SYSTEM_TABLE=1670;ER_BINLOG_UNSAFE_AUTOINC_COLUMNS=1671;ER_BINLOG_UNSAFE_UDF=1672;ER_BINLOG_UNSAFE_SYSTEM_VARIABLE=1673;ER_BINLOG_UNSAFE_SYSTEM_FUNCTION=1674;ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS=1675;ER_MESSAGE_AND_STATEMENT=1676;ER_SLAVE_CONVERSION_FAILED=1677;ER_SLAVE_CANT_CREATE_CONVERSION=1678;ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT=1679;ER_PATH_LENGTH=1680;ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT=1681;ER_WRONG_NATIVE_TABLE_STRUCTURE=1682;ER_WRONG_PERFSCHEMA_USAGE=1683;ER_WARN_I_S_SKIPPED_TABLE=1684;ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT=1685;ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT=1686;ER_SPATIAL_MUST_HAVE_GEOM_COL=1687;ER_TOO_LONG_INDEX_COMMENT=1688;ER_LOCK_ABORTED=1689;ER_DATA_OUT_OF_RANGE=1690;ER_WRONG_SPVAR_TYPE_IN_LIMIT=1691;ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE=1692;ER_BINLOG_UNSAFE_MIXED_STATEMENT=1693;ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN=1694;ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN=1695;ER_FAILED_READ_FROM_PAR_FILE=1696;ER_VALUES_IS_NOT_INT_TYPE_ERROR=1697;ER_ACCESS_DENIED_NO_PASSWORD_ERROR=1698;ER_SET_PASSWORD_AUTH_PLUGIN=1699;ER_GRANT_PLUGIN_USER_EXISTS=1700;ER_TRUNCATE_ILLEGAL_FK=1701;ER_PLUGIN_IS_PERMANENT=1702;ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN=1703;ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX=1704;ER_ERROR_LAST=1704
  end

  ServerError.define_error_class(/\AER_/)
  ServerError::ERROR_MAP.values.each{|v| Mysql.const_set v.name.split(/::/).last, v} # for compatibility

  # client side error
  class ClientError < Error
    ERROR_MAP = {}

CR_UNKNOWN_ERROR=2000;CR_SOCKET_CREATE_ERROR=2001;CR_CONNECTION_ERROR=2002;CR_CONN_HOST_ERROR=2003;CR_IPSOCK_ERROR=2004;CR_UNKNOWN_HOST=2005;CR_SERVER_GONE_ERROR=2006;CR_VERSION_ERROR=2007;CR_OUT_OF_MEMORY=2008;CR_WRONG_HOST_INFO=2009;CR_LOCALHOST_CONNECTION=2010;CR_TCP_CONNECTION=2011;CR_SERVER_HANDSHAKE_ERR=2012;CR_SERVER_LOST=2013;CR_COMMANDS_OUT_OF_SYNC=2014;CR_NAMEDPIPE_CONNECTION=2015;CR_NAMEDPIPEWAIT_ERROR=2016;CR_NAMEDPIPEOPEN_ERROR=2017;CR_NAMEDPIPESETSTATE_ERROR=2018;CR_CANT_READ_CHARSET=2019;CR_NET_PACKET_TOO_LARGE=2020;CR_EMBEDDED_CONNECTION=2021;CR_PROBE_SLAVE_STATUS=2022;CR_PROBE_SLAVE_HOSTS=2023;CR_PROBE_SLAVE_CONNECT=2024;CR_PROBE_MASTER_CONNECT=2025;CR_SSL_CONNECTION_ERROR=2026;CR_MALFORMED_PACKET=2027;CR_WRONG_LICENSE=2028;CR_NULL_POINTER=2029;CR_NO_PREPARE_STMT=2030;CR_PARAMS_NOT_BOUND=2031;CR_DATA_TRUNCATED=2032;CR_NO_PARAMETERS_EXISTS=2033;CR_INVALID_PARAMETER_NO=2034;CR_INVALID_BUFFER_USE=2035;CR_UNSUPPORTED_PARAM_TYPE=2036;CR_SHARED_MEMORY_CONNECTION=2037;CR_SHARED_MEMORY_CONNECT_REQUEST_ERROR=2038;CR_SHARED_MEMORY_CONNECT_ANSWER_ERROR=2039;CR_SHARED_MEMORY_CONNECT_FILE_MAP_ERROR=2040;CR_SHARED_MEMORY_CONNECT_MAP_ERROR=2041;CR_SHARED_MEMORY_FILE_MAP_ERROR=2042;CR_SHARED_MEMORY_MAP_ERROR=2043;CR_SHARED_MEMORY_EVENT_ERROR=2044;CR_SHARED_MEMORY_CONNECT_ABANDONED_ERROR=2045;CR_SHARED_MEMORY_CONNECT_SET_ERROR=2046;CR_CONN_UNKNOW_PROTOCOL=2047;CR_INVALID_CONN_HANDLE=2048;CR_SECURE_AUTH=2049;CR_FETCH_CANCELED=2050;CR_NO_DATA=2051;CR_NO_STMT_METADATA=2052;CR_NO_RESULT_SET=2053;CR_NOT_IMPLEMENTED=2054;CR_SERVER_LOST_EXTENDED=2055;CR_STMT_CLOSED=2056;CR_NEW_STMT_METADATA=2057;CR_ALREADY_CONNECTED=2058;CR_AUTH_PLUGIN_CANNOT_LOAD=2059
  end

  ClientError.define_error_class(/\ACR_/)

  # protocol error
  class ProtocolError < ClientError
  end
  
  
  # MySQL network protocol
  class Protocol

    VERSION = 10
    MAX_PACKET_LENGTH = 2**24-1

    # convert Numeric to LengthCodedBinary
    def self.lcb(num)
      return "\xfb" if num.nil?
      return [num].pack("C") if num < 251
      return [252, num].pack("Cv") if num < 65536
      return [253, num&0xffff, num>>16].pack("CvC") if num < 16777216
      return [254, num&0xffffffff, num>>32].pack("CVV")
    end

    # convert String to LengthCodedString
    def self.lcs(str)
      str = Charset.to_binary str
      lcb(str.length)+str
    end

    # convert LengthCodedBinary to Integer
    # === Argument
    # lcb :: [String] LengthCodedBinary. This value will be broken.
    # === Return
    # Integer or nil
    def self.lcb2int!(lcb)
      return nil if lcb.empty?
      case v = lcb.slice!(0)
      when ?\xfb
        return nil
      when ?\xfc
        return lcb.slice!(0,2).unpack("v").first
      when ?\xfd
        c, v = lcb.slice!(0,3).unpack("Cv")
        return (v << 8)+c
      when ?\xfe
        v1, v2 = lcb.slice!(0,8).unpack("VV")
        return (v2 << 32)+v1
      else
        return v.ord
      end
    end

    # convert LengthCodedString to String
    # === Argument
    # lcs :: [String] LengthCodedString. This value will be broken.
    # === Return
    # String or nil
    def self.lcs2str!(lcs)
      len = lcb2int! lcs
      return len && lcs.slice!(0, len)
    end

    def self.eof_packet?(data)
      data[0] == ?\xfe && data.length == 5
    end

    # Convert netdata to Ruby value
    # === Argument
    # data :: [String] packet data. This will be broken.
    # type :: [Integer] field type
    # unsigned :: [true or false] true if value is unsigned
    # === Return
    # Object :: converted value.
    def self.net2value(data, type, unsigned)
      case type
      when Field::TYPE_STRING, Field::TYPE_VAR_STRING, Field::TYPE_NEWDECIMAL, Field::TYPE_BLOB
        return lcs2str!(data)
      when Field::TYPE_TINY
        v = data.slice!(0).ord
        return unsigned ? v : v < 128 ? v : v-256
      when Field::TYPE_SHORT
        v = data.slice!(0,2).unpack("v").first
        return unsigned ? v : v < 32768 ? v : v-65536
      when Field::TYPE_INT24, Field::TYPE_LONG
        v = data.slice!(0,4).unpack("V").first
        return unsigned ? v : v < 2**32/2 ? v : v-2**32
      when Field::TYPE_LONGLONG
        n1, n2 = data.slice!(0,8).unpack("VV")
        v = (n2 << 32) | n1
        return unsigned ? v : v < 2**64/2 ? v : v-2**64
      when Field::TYPE_FLOAT
        return data.slice!(0,4).unpack("e").first
      when Field::TYPE_DOUBLE
        return data.slice!(0,8).unpack("E").first
      when Field::TYPE_DATE, Field::TYPE_DATETIME, Field::TYPE_TIMESTAMP
        len = data.slice!(0).ord
        y, m, d, h, mi, s, bs = data.slice!(0,len).unpack("vCCCCCV")
        return Mysql::Time.new(y, m, d, h, mi, s, bs)
      when Field::TYPE_TIME
        len = data.slice!(0).ord
        sign, d, h, mi, s, sp = data.slice!(0,len).unpack("CVCCCV")
        h = d.to_i * 24 + h.to_i
        return Mysql::Time.new(0, 0, 0, h, mi, s, sign!=0, sp)
      when Field::TYPE_YEAR
        return data.slice!(0,2).unpack("v").first
      when Field::TYPE_BIT
        return lcs2str!(data)
      else
        raise "not implemented: type=#{type}"
      end
    end

    # convert Ruby value to netdata
    # === Argument
    # v :: [Object] Ruby value.
    # === Return
    # Integer :: type of column. Field::TYPE_*
    # String :: netdata
    # === Exception
    # ProtocolError :: value too large / value is not supported
    def self.value2net(v)
      case v
      when nil
        type = Field::TYPE_NULL
        val = ""
      when Integer
        if v >= 0
          if v < 256
            type = Field::TYPE_TINY | 0x8000
            val = [v].pack("C")
          elsif v < 256**2
            type = Field::TYPE_SHORT | 0x8000
            val = [v].pack("v")
          elsif v < 256**4
            type = Field::TYPE_LONG | 0x8000
            val = [v].pack("V")
          elsif v < 256**8
            type = Field::TYPE_LONGLONG | 0x8000
            val = [v&0xffffffff, v>>32].pack("VV")
          else
            raise ProtocolError, "value too large: #{v}"
          end
        else
          if -v <= 256/2
            type = Field::TYPE_TINY
            val = [v].pack("C")
          elsif -v <= 256**2/2
            type = Field::TYPE_SHORT
            val = [v].pack("v")
          elsif -v <= 256**4/2
            type = Field::TYPE_LONG
            val = [v].pack("V")
          elsif -v <= 256**8/2
            type = Field::TYPE_LONGLONG
            val = [v&0xffffffff, v>>32].pack("VV")
          else
            raise ProtocolError, "value too large: #{v}"
          end
        end
      when Float
        type = Field::TYPE_DOUBLE
        val = [v].pack("E")
      when String
        type = Field::TYPE_STRING
        val = lcs(v)
      when Mysql::Time, ::Time
        type = Field::TYPE_DATETIME
        val = [7, v.year, v.month, v.day, v.hour, v.min, v.sec].pack("CvCCCCC")
      else
        raise ProtocolError, "class #{v.class} is not supported"
      end
      return type, val
    end

    attr_reader :server_info
    attr_reader :server_version
    attr_reader :thread_id
    attr_reader :sqlstate
    attr_reader :affected_rows
    attr_reader :insert_id
    attr_reader :server_status
    attr_reader :warning_count
    attr_reader :message
    attr_accessor :charset

    # @state variable keep state for connection.
    # :INIT   :: Initial state.
    # :READY  :: Ready for command.
    # :FIELD  :: After query(). retr_fields() is needed.
    # :RESULT :: After retr_fields(), retr_all_records() or stmt_retr_all_records() is needed.

    # make socket connection to server.
    # === Argument
    # host :: [String] if "localhost" or "" nil then use UNIXSocket. Otherwise use TCPSocket
    # port :: [Integer] port number using by TCPSocket
    # socket :: [String] socket file name using by UNIXSocket
    # conn_timeout :: [Integer] connect timeout (sec).
    # read_timeout :: [Integer] read timeout (sec).
    # write_timeout :: [Integer] write timeout (sec).
    # === Exception
    # [ClientError] :: connection timeout
    def initialize(host, port, socket, conn_timeout, read_timeout, write_timeout)
      @gc_stmt_queue = []   # stmt id list which GC destroy.
      set_state :INIT
      @read_timeout = read_timeout
      @write_timeout = write_timeout
      begin
        Timeout.timeout conn_timeout do
          if host.nil? or host.empty? or host == "localhost"
            socket ||= ENV["MYSQL_UNIX_PORT"] || MYSQL_UNIX_PORT
            @sock = UNIXSocket.new socket
          else
            port ||= ENV["MYSQL_TCP_PORT"] || (Socket.getservbyname("mysql","tcp") rescue MYSQL_TCP_PORT)
            @sock = TCPSocket.new host, port
          end
        end
      rescue Timeout::Error
        raise ClientError, "connection timeout"
      end
    end

    def close
      @sock.close
    end

    # initial negotiate and authenticate.
    # === Argument
    # user    :: [String / nil] username
    # passwd  :: [String / nil] password
    # db      :: [String / nil] default database name. nil: no default.
    # flag    :: [Integer] client flag
    # charset :: [Mysql::Charset / nil] charset for connection. nil: use server's charset
    def authenticate(user, passwd, db, flag, charset)
      check_state :INIT
      @authinfo = [user, passwd, db, flag, charset]
      reset
      init_packet = InitialPacket.parse read
      @server_info = init_packet.server_version
      @server_version = init_packet.server_version.split(/\D/)[0,3].inject{|a,b|a.to_i*100+b.to_i}
      @thread_id = init_packet.thread_id
      client_flags = CLIENT_LONG_PASSWORD | CLIENT_LONG_FLAG | CLIENT_TRANSACTIONS | CLIENT_PROTOCOL_41 | CLIENT_SECURE_CONNECTION
      client_flags |= CLIENT_CONNECT_WITH_DB if db
      client_flags |= flag
      @charset = charset
      unless @charset
        @charset = Charset.by_number(init_packet.server_charset)
        @charset.encoding       # raise error if unsupported charset
      end
      netpw = encrypt_password passwd, init_packet.scramble_buff
      write AuthenticationPacket.serialize(client_flags, 1024**3, @charset.number, user, netpw, db)
      read            # skip OK packet
      set_state :READY
    end

    # Quit command
    def quit_command
      synchronize do
        reset
        write [COM_QUIT].pack("C")
        close
      end
    end

    # Query command
    # === Argument
    # query :: [String] query string
    # === Return
    # [Integer / nil] number of fields of results. nil if no results.
    def query_command(query)
      check_state :READY
      begin
        reset
        write [COM_QUERY, @charset.convert(query)].pack("Ca*")
        get_result
      rescue
        set_state :READY
        raise
      end
    end

    # get result of query.
    # === Return
    # [integer / nil] number of fields of results. nil if no results.
    def get_result
      begin
        res_packet = ResultPacket.parse read
        if res_packet.field_count.to_i > 0  # result data exists
          set_state :FIELD
          return res_packet.field_count
        end
        if res_packet.field_count.nil?      # LOAD DATA LOCAL INFILE
          filename = res_packet.message
          File.open(filename){|f| write f}
          write nil  # EOF mark
          read
        end
        @affected_rows, @insert_id, @server_status, @warning_count, @message =
          res_packet.affected_rows, res_packet.insert_id, res_packet.server_status, res_packet.warning_count, res_packet.message
        set_state :READY
        return nil
      rescue
        set_state :READY
        raise
      end
    end

    # Retrieve n fields
    # === Argument
    # n :: [Integer] number of fields
    # === Return
    # [Array of Mysql::Field] field list
    def retr_fields(n)
      check_state :FIELD
      begin
        fields = n.times.map{Field.new FieldPacket.parse(read)}
        read_eof_packet
        set_state :RESULT
        fields
      rescue
        set_state :READY
        raise
      end
    end

    # Retrieve all records for simple query
    # === Argument
    # fields :: [Array of Mysql::Field] field list
    # === Return
    # [Array of Array of String] all records
    def retr_all_records(fields)
      check_state :RESULT
      begin
        all_recs = []
        until self.class.eof_packet?(data = read)
          rec = fields.map do
            s = self.class.lcs2str!(data)
            s && Charset.convert_encoding(s, charset.encoding)
          end
          all_recs.push rec
        end
        @server_status = data[3].ord
        all_recs
      ensure
        set_state :READY
      end
    end

    # Field list command
    # === Argument
    # table :: [String] table name.
    # field :: [String / nil] field name that may contain wild card.
    # === Return
    # [Array of Field] field list
    def field_list_command(table, field)
      synchronize do
        reset
        write [COM_FIELD_LIST, table, 0, field].pack("Ca*Ca*")
        fields = []
        until self.class.eof_packet?(data = read)
          fields.push Field.new(FieldPacket.parse(data))
        end
        return fields
      end
    end

    # Process info command
    # === Return
    # [Array of Field] field list
    def process_info_command
      check_state :READY
      begin
        reset
        write [COM_PROCESS_INFO].pack("C")
        field_count = self.class.lcb2int!(read)
        fields = field_count.times.map{Field.new FieldPacket.parse(read)}
        read_eof_packet
        set_state :RESULT
        return fields
      rescue
        set_state :READY
        raise
      end
    end

    # Ping command
    def ping_command
      simple_command [COM_PING].pack("C")
    end

    # Kill command
    def kill_command(pid)
      simple_command [COM_PROCESS_KILL, pid].pack("CV")
    end

    # Refresh command
    def refresh_command(op)
      simple_command [COM_REFRESH, op].pack("CC")
    end

    # Set option command
    def set_option_command(opt)
      simple_command [COM_SET_OPTION, opt].pack("Cv")
    end

    # Shutdown command
    def shutdown_command(level)
      simple_command [COM_SHUTDOWN, level].pack("CC")
    end

    # Statistics command
    def statistics_command
      simple_command [COM_STATISTICS].pack("C")
    end

    # Stmt prepare command
    # === Argument
    # stmt :: [String] prepared statement
    # === Return
    # [Integer] statement id
    # [Integer] number of parameters
    # [Array of Field] field list
    def stmt_prepare_command(stmt)
      synchronize do
        reset
        write [COM_STMT_PREPARE, charset.convert(stmt)].pack("Ca*")
        res_packet = PrepareResultPacket.parse read
        if res_packet.param_count > 0
          res_packet.param_count.times{read}    # skip parameter packet
          read_eof_packet
        end
        if res_packet.field_count > 0
          fields = res_packet.field_count.times.map{Field.new FieldPacket.parse(read)}
          read_eof_packet
        else
          fields = []
        end
        return res_packet.statement_id, res_packet.param_count, fields
      end
    end

    # Stmt execute command
    # === Argument
    # stmt_id :: [Integer] statement id
    # values  :: [Array] parameters
    # === Return
    # [Integer] number of fields
    def stmt_execute_command(stmt_id, values)
      check_state :READY
      begin
        reset
        write ExecutePacket.serialize(stmt_id, Mysql::Stmt::CURSOR_TYPE_NO_CURSOR, values)
        get_result
      rescue
        set_state :READY
        raise
      end
    end

    # Retrieve all records for prepared statement
    # === Argument
    # fields  :: [Array of Mysql::Fields] field list
    # charset :: [Mysql::Charset]
    # === Return
    # [Array of Array of Object] all records
    def stmt_retr_all_records(fields, charset)
      check_state :RESULT
      begin
        all_recs = []
        until self.class.eof_packet?(data = read)
          all_recs.push stmt_parse_record_packet(data, fields, charset)
        end
        all_recs
      ensure
        set_state :READY
      end
    end

    # Stmt close command
    # === Argument
    # stmt_id :: [Integer] statement id
    def stmt_close_command(stmt_id)
      synchronize do
        reset
        write [COM_STMT_CLOSE, stmt_id].pack("CV")
      end
    end

    def gc_stmt(stmt_id)
      @gc_stmt_queue.push stmt_id
    end

    private

    # Parse statement result packet
    # === Argument
    # data    :: [String]
    # fields  :: [Array of Fields]
    # charset :: [Mysql::Charset]
    # === Return
    # [Array of Object] one record
    def stmt_parse_record_packet(data, fields, charset)
      data.slice!(0)  # skip first byte
      null_bit_map = data.slice!(0, (fields.length+7+2)/8).unpack("b*").first
      rec = fields.each_with_index.map do |f, i|
        if null_bit_map[i+2] == ?1
          nil
        else
          unsigned = f.flags & Field::UNSIGNED_FLAG != 0
          v = self.class.net2value(data, f.type, unsigned)
          if v.is_a? Numeric or v.is_a? Mysql::Time
            v
          elsif f.type == Field::TYPE_BIT or f.charsetnr == Charset::BINARY_CHARSET_NUMBER
            Charset.to_binary(v)
          else
            Charset.convert_encoding(v, charset.encoding)
          end
        end
      end
      rec
    end

    def check_state(st)
      raise 'command out of sync' unless @state == st
    end

    def set_state(st)
      @state = st
      if st == :READY
        gc_disabled = GC.disable
        begin
          while st = @gc_stmt_queue.shift
            reset
            write [COM_STMT_CLOSE, st].pack("CV")
          end
        ensure
          GC.enable unless gc_disabled
        end
      end
    end

    def synchronize
      begin
        check_state :READY
        return yield
      ensure
        set_state :READY
      end
    end

    # Reset sequence number
    def reset
      @seq = 0    # packet counter. reset by each command
    end

    # Read one packet data
    # === Return
    # [String] packet data
    # === Exception
    # [ProtocolError] invalid packet sequence number
    def read
      ret = ""
      len = nil
      begin
        Timeout.timeout @read_timeout do
          header = @sock.sysread(4)
          len1, len2, seq = header.unpack("CvC")
          len = (len2 << 8) + len1
          raise ProtocolError, "invalid packet: sequence number mismatch(#{seq} != #{@seq}(expected))" if @seq != seq
          @seq = (@seq + 1) % 256
          ret.concat @sock.sysread(len)
        end
      rescue EOFError
        raise ClientError::ServerGoneError, 'The MySQL server has gone away'
      rescue Timeout::Error
        raise ClientError, "read timeout"
      end while len == MAX_PACKET_LENGTH

      @sqlstate = "00000"

      # Error packet
      if ret[0] == ?\xff
        f, errno, marker, @sqlstate, message = ret.unpack("Cvaa5a*")
        unless marker == "#"
          f, errno, message = ret.unpack("Cva*")    # Version 4.0 Error
          @sqlstate = ""
        end
        if Mysql::ServerError::ERROR_MAP.key? errno
          raise Mysql::ServerError::ERROR_MAP[errno].new(message, @sqlstate)
        end
        raise Mysql::ServerError.new(message, @sqlstate)
      end
      ret
    end

    # Write one packet data
    # === Argument
    # data :: [String / IO] packet data. If data is nil, write empty packet.
    def write(data)
      begin
        @sock.sync = false
        if data.nil?
          Timeout.timeout @write_timeout do
            @sock.write [0, 0, @seq].pack("CvC")
          end
          @seq = (@seq + 1) % 256
        else
          data = StringIO.new data if data.is_a? String
          while d = data.read(MAX_PACKET_LENGTH)
            Timeout.timeout @write_timeout do
              @sock.write [d.length%256, d.length/256, @seq].pack("CvC")
              @sock.write d
            end
            @seq = (@seq + 1) % 256
          end
        end
        @sock.sync = true
        Timeout.timeout @write_timeout do
          @sock.flush
        end
      rescue Errno::EPIPE
        raise ClientError::ServerGoneError, 'The MySQL server has gone away'
      rescue Timeout::Error
        raise ClientError, "write timeout"
      end
    end

    # Read EOF packet
    # === Exception
    # [ProtocolError] packet is not EOF
    def read_eof_packet
      data = read
      raise ProtocolError, "packet is not EOF" unless self.class.eof_packet? data
    end

    # Send simple command
    # === Argument
    # packet :: [String] packet data
    # === Return
    # [String] received data
    def simple_command(packet)
      synchronize do
        reset
        write packet
        read
      end
    end

    # Encrypt password
    # === Argument
    # plain    :: [String] plain password.
    # scramble :: [String] scramble code from initial packet.
    # === Return
    # [String] encrypted password
    def encrypt_password(plain, scramble)
      return "" if plain.nil? or plain.empty?
      hash_stage1 = Digest::SHA1.digest plain
      hash_stage2 = Digest::SHA1.digest hash_stage1
      return hash_stage1.unpack("C*").zip(Digest::SHA1.digest(scramble+hash_stage2).unpack("C*")).map{|a,b| a^b}.pack("C*")
    end

    # Initial packet
    class InitialPacket
      def self.parse(data)
        protocol_version, server_version, thread_id, scramble_buff, f0,
        server_capabilities, server_charset, server_status, f1,
        rest_scramble_buff = data.unpack("CZ*Va8CvCva13Z13")
        raise ProtocolError, "unsupported version: #{protocol_version}" unless protocol_version == VERSION
        raise ProtocolError, "invalid packet: f0=#{f0}" unless f0 == 0
        scramble_buff.concat rest_scramble_buff
        self.new protocol_version, server_version, thread_id, server_capabilities, server_charset, server_status, scramble_buff
      end

      attr_reader :protocol_version, :server_version, :thread_id, :server_capabilities, :server_charset, :server_status, :scramble_buff

      def initialize(*args)
        @protocol_version, @server_version, @thread_id, @server_capabilities, @server_charset, @server_status, @scramble_buff = args
      end
    end

    # Result packet
    class ResultPacket
      def self.parse(data)
        field_count = Protocol.lcb2int! data
        if field_count == 0
          affected_rows = Protocol.lcb2int! data
          insert_id = Protocol.lcb2int!(data)
          server_status, warning_count, message = data.unpack("vva*")
          return self.new(field_count, affected_rows, insert_id, server_status, warning_count, Protocol.lcs2str!(message))
        elsif field_count.nil?   # LOAD DATA LOCAL INFILE
          return self.new(nil, nil, nil, nil, nil, data)
        else
          return self.new(field_count)
        end
      end

      attr_reader :field_count, :affected_rows, :insert_id, :server_status, :warning_count, :message

      def initialize(*args)
        @field_count, @affected_rows, @insert_id, @server_status, @warning_count, @message = args
      end
    end

    # Field packet
    class FieldPacket
      def self.parse(data)
        first = Protocol.lcs2str! data
        db = Protocol.lcs2str! data
        table = Protocol.lcs2str! data
        org_table = Protocol.lcs2str! data
        name = Protocol.lcs2str! data
        org_name = Protocol.lcs2str! data
        f0, charsetnr, length, type, flags, decimals, f1, data = data.unpack("CvVCvCva*")
        raise ProtocolError, "invalid packet: f1=#{f1}" unless f1 == 0
        default = Protocol.lcs2str! data
        return self.new(db, table, org_table, name, org_name, charsetnr, length, type, flags, decimals, default)
      end

      attr_reader :db, :table, :org_table, :name, :org_name, :charsetnr, :length, :type, :flags, :decimals, :default

      def initialize(*args)
        @db, @table, @org_table, @name, @org_name, @charsetnr, @length, @type, @flags, @decimals, @default = args
      end
    end

    # Prepare result packet
    class PrepareResultPacket
      def self.parse(data)
        raise ProtocolError, "invalid packet" unless data.slice!(0) == ?\0
        statement_id, field_count, param_count, f, warning_count = data.unpack("VvvCv")
        raise ProtocolError, "invalid packet" unless f == 0x00
        self.new statement_id, field_count, param_count, warning_count
      end

      attr_reader :statement_id, :field_count, :param_count, :warning_count

      def initialize(*args)
        @statement_id, @field_count, @param_count, @warning_count = args
      end
    end

    # Authentication packet
    class AuthenticationPacket
      def self.serialize(client_flags, max_packet_size, charset_number, username, scrambled_password, databasename)
        [
          client_flags,
          max_packet_size,
          Protocol.lcb(charset_number),
          "",                   # always 0x00 * 23
          username,
          Protocol.lcs(scrambled_password),
          databasename
        ].pack("VVa*a23Z*A*Z*")
      end
    end

    # Execute packet
    class ExecutePacket
      def self.serialize(statement_id, cursor_type, values)
        nbm = null_bitmap values
        netvalues = ""
        types = values.map do |v|
          t, n = Protocol.value2net v
          netvalues.concat n if v
          t
        end
        [Mysql::COM_STMT_EXECUTE, statement_id, cursor_type, 1, nbm, 1, types.pack("v*"), netvalues].pack("CVCVa*Ca*a*")
      end

      # make null bitmap
      #
      # If values is [1, nil, 2, 3, nil] then returns "\x12"(0b10010).
      def self.null_bitmap(values)
        bitmap = values.enum_for(:each_slice,8).map do |vals|
          vals.reverse.inject(0){|b, v|(b << 1 | (v ? 0 : 1))}
        end
        return bitmap.pack("C*")
      end

    end
  end
  

  dir = File.dirname __FILE__

  VERSION = 20904; MYSQL_UNIX_PORT = "/var/run/mysqld/mysqld.sock"; MYSQL_TCP_PORT = 3306

  attr_reader :charset               # character set of MySQL connection
  attr_reader :affected_rows         # number of affected records by insert/update/delete.
  attr_reader :warning_count         # number of warnings for previous query
  attr_reader :protocol              # :nodoc:

  attr_accessor :query_with_result

  class << self
    # Make Mysql object without connecting.
    def init
      my = self.allocate
      my.instance_eval{initialize}
      my
    end

    # Make Mysql object and connect to mysqld.
    # Arguments are same as Mysql#connect.
    def new(*args)
      my = self.init
      my.connect(*args)
    end

    alias real_connect new
    alias connect new

    # Escape special character in string.
    # === Argument
    # str :: [String]
    def escape_string(str)
      str.gsub(/[\0\n\r\\\'\"\x1a]/) do |s|
        case s
        when "\0" then "\\0"
        when "\n" then "\\n"
        when "\r" then "\\r"
        when "\x1a" then "\\Z"
        else "\\#{s}"
        end
      end
    end
    alias quote escape_string

    # Return client version as String.
    # This value is dummy.
    def client_info
      "5.0.0"
    end
    alias get_client_info client_info

    # Return client version as Integer.
    # This value is dummy. If you want to get version of this library, use Mysql::VERSION.
    def client_version
      50000
    end
    alias get_client_version client_version
  end

  def initialize  # :nodoc:
@fields=nil;@protocol=nil;@charset=nil;@connect_timeout=nil;@read_timeout=nil;@write_timeout=nil;@init_command=nil;@affected_rows=nil;@warning_count=0;@sqlstate="00000";@query_with_result=true;@host_info=nil;@info=nil;@last_error=nil;@result_exist=false;@local_infile=nil
  end

  # Connect to mysqld.
  # === Argument
  # host   :: [String / nil] hostname mysqld running
  # user   :: [String / nil] username to connect to mysqld
  # passwd :: [String / nil] password to connect to mysqld
  # db     :: [String / nil] initial database name
  # port   :: [Integer / nil] port number (used if host is not 'localhost' or nil)
  # socket :: [String / nil] socket file name (used if host is 'localhost' or nil)
  # flag   :: [Integer / nil] connection flag. Mysql::CLIENT_* ORed
  # === Return
  # self
  def connect(host=nil, user=nil, passwd=nil, db=nil, port=nil, socket=nil, flag=0)
    if flag & CLIENT_COMPRESS != 0
      warn 'unsupported flag: CLIENT_COMPRESS'
      flag &= ~CLIENT_COMPRESS
    end
    @protocol = Protocol.new host, port, socket, @connect_timeout, @read_timeout, @write_timeout
    @protocol.authenticate user, passwd, db, (@local_infile ? CLIENT_LOCAL_FILES : 0) | flag, @charset
    @charset ||= @protocol.charset
    @host_info = (host.nil? || host == "localhost") ? 'Localhost via UNIX socket' : "#{host} via TCP/IP"
    query @init_command if @init_command
    return self
  end
  alias real_connect connect

  # Disconnect from mysql.
  def close
    if @protocol
      @protocol.quit_command
      @protocol = nil
    end
    return self
  end

  # Disconnect from mysql without QUIT packet.
  def close!
    if @protocol
      @protocol.close
      @protocol = nil
    end
    return self
  end

  # Set option for connection.
  #
  # Available options:
  #   Mysql::INIT_COMMAND, Mysql::OPT_CONNECT_TIMEOUT, Mysql::OPT_READ_TIMEOUT,
  #   Mysql::OPT_WRITE_TIMEOUT, Mysql::SET_CHARSET_NAME
  # === Argument
  # opt   :: [Integer] option
  # value :: option value that is depend on opt
  # === Return
  # self
  def options(opt, value=nil)
    case opt
    when Mysql::INIT_COMMAND
      @init_command = value.to_s
#    when Mysql::OPT_COMPRESS
    when Mysql::OPT_CONNECT_TIMEOUT
      @connect_timeout = value
#    when Mysql::GUESS_CONNECTION
    when Mysql::OPT_LOCAL_INFILE
      @local_infile = value
#    when Mysql::OPT_NAMED_PIPE
#    when Mysql::OPT_PROTOCOL
    when Mysql::OPT_READ_TIMEOUT
      @read_timeout = value.to_i
#    when Mysql::OPT_RECONNECT
#    when Mysql::SET_CLIENT_IP
#    when Mysql::OPT_SSL_VERIFY_SERVER_CERT
#    when Mysql::OPT_USE_EMBEDDED_CONNECTION
#    when Mysql::OPT_USE_REMOTE_CONNECTION
    when Mysql::OPT_WRITE_TIMEOUT
      @write_timeout = value.to_i
#    when Mysql::READ_DEFAULT_FILE
#    when Mysql::READ_DEFAULT_GROUP
#    when Mysql::REPORT_DATA_TRUNCATION
#    when Mysql::SECURE_AUTH
#    when Mysql::SET_CHARSET_DIR
    when Mysql::SET_CHARSET_NAME
      @charset = Charset.by_name value.to_s
#    when Mysql::SHARED_MEMORY_BASE_NAME
    else
      warn "option not implemented: #{opt}"
    end
    self
  end

  # Escape special character in MySQL.
  # === Note
  # In Ruby 1.8, this is not safe for multibyte charset such as 'SJIS'.
  # You should use place-holder in prepared-statement.
  def escape_string(str)
    if not defined? Encoding and @charset.unsafe
      raise ClientError, 'Mysql#escape_string is called for unsafe multibyte charset'
    end
    self.class.escape_string str
  end
  alias quote escape_string

  # === Return
  # [String] client version
  def client_info
    self.class.client_info
  end
  alias get_client_info client_info

  # === Return
  # [Integer] client version
  def client_version
    self.class.client_version
  end
  alias get_client_version client_version

  # Set charset of MySQL connection.
  # === Argument
  # cs :: [String / Mysql::Charset]
  # === Return
  # cs
  def charset=(cs)
    charset = cs.is_a?(Charset) ? cs : Charset.by_name(cs)
    if @protocol
      @protocol.charset = charset
      query "SET NAMES #{charset.name}"
    end
    @charset = charset
    cs
  end

  # === Return
  # [String] charset name
  def character_set_name
    @charset.name
  end

  # === Return
  # [Integer] last error number
  def errno
    @last_error ? @last_error.errno : 0
  end

  # === Return
  # [String] last error message
  def error
    @last_error && @last_error.error
  end

  # === Return
  # [String] sqlstate for last error
  def sqlstate
    @last_error ? @last_error.sqlstate : "00000"
  end

  # === Return
  # [Integer] number of columns for last query
  def field_count
    @fields.size
  end

  # === Return
  # [String] connection type
  def host_info
    @host_info
  end
  alias get_host_info host_info

  # === Return
  # [Integer] protocol version
  def proto_info
    Mysql::Protocol::VERSION
  end
  alias get_proto_info proto_info

  # === Return
  # [String] server version
  def server_info
    check_connection
    @protocol.server_info
  end
  alias get_server_info server_info

  # === Return
  # [Integer] server version
  def server_version
    check_connection
    @protocol.server_version
  end
  alias get_server_version server_version

  # === Return
  # [String] information for last query
  def info
    @info
  end

  # === Return
  # [Integer] latest auto_increment value
  def insert_id
    @insert_id
  end

  # Kill query.
  # === Argument
  # pid :: [Integer] thread id
  # === Return
  # self
  def kill(pid)
    check_connection
    @protocol.kill_command pid
    self
  end

  # Return database list.
  # === Argument
  # db :: [String] database name that may contain wild card.
  # === Return
  # [Array of String] database list
  def list_dbs(db=nil)
    db &&= db.gsub(/[\\\']/){"\\#{$&}"}
    query(db ? "show databases like '#{db}'" : "show databases").map(&:first)
  end

  # Execute query string.
  # === Argument
  # str :: [String] Query.
  # block :: If it is given then it is evaluated with Result object as argument.
  # === Return
  # Mysql::Result :: If result set exist.
  # nil :: If the query does not return result set.
  # self :: If block is specified.
  # === Block parameter
  # [Mysql::Result]
  # === Example
  #  my.query("select 1,NULL,'abc'").fetch  # => [1, nil, "abc"]
  def query(str, &block)
    check_connection
    @fields = nil
    begin
      nfields = @protocol.query_command str
      if nfields
        @fields = @protocol.retr_fields nfields
        @result_exist = true
      else
        @affected_rows, @insert_id, @server_status, @warning_count, @info =
          @protocol.affected_rows, @protocol.insert_id, @protocol.server_status, @protocol.warning_count, @protocol.message
      end
      if block
        while true
          block.call store_result if @fields
          break unless next_result
        end
        return self
      end
      if @query_with_result
        return @fields ? store_result : nil
      else
        return self
      end
    rescue ServerError => e
      @last_error = e
      @sqlstate = e.sqlstate
      raise
    end
  end
  alias real_query query

  # Get all data for last query if query_with_result is false.
  # === Return
  # [Mysql::Result]
  def store_result
    check_connection
    raise ClientError, 'invalid usage' unless @result_exist
    res = Result.new @fields, @protocol
    @server_status = @protocol.server_status
    @result_exist = false
    res
  end

  # Returns thread ID.
  # === Return
  # [Integer] Thread ID
  def thread_id
    check_connection
    @protocol.thread_id
  end

  # Use result of query. The result data is retrieved when you use Mysql::Result#fetch_row.
  def use_result
    store_result
  end

  # Set server option.
  # === Argument
  # opt :: [Integer] Mysql::OPTION_MULTI_STATEMENTS_ON or Mysql::OPTION_MULTI_STATEMENTS_OFF
  # === Return
  # self
  def set_server_option(opt)
    check_connection
    @protocol.set_option_command opt
    self
  end

  # true if multiple queries are specified and unexecuted queries exists.
  def more_results
    @server_status & SERVER_MORE_RESULTS_EXISTS != 0
  end
  alias more_results? more_results

  # execute next query if multiple queries are specified.
  # === Return
  # true if next query exists.
  def next_result
    return false unless more_results
    check_connection
    @fields = nil
    nfields = @protocol.get_result
    if nfields
      @fields = @protocol.retr_fields nfields
      @result_exist = true
    end
    return true
  end

  # Parse prepared-statement.
  # === Argument
  # str :: [String] query string
  # === Return
  # Mysql::Statement :: Prepared-statement object
  def prepare(str)
    st = Stmt.new @protocol, @charset
    st.prepare str
    st
  end

  # Make empty prepared-statement object.
  # === Return
  # Mysql::Stmt :: If block is not specified.
  def stmt_init
    Stmt.new @protocol, @charset
  end

  # Returns Mysql::Result object that is empty.
  # Use fetch_fields to get list of fields.
  # === Argument
  # table :: [String] table name.
  # field :: [String] field name that may contain wild card.
  # === Return
  # [Mysql::Result]
  def list_fields(table, field=nil)
    check_connection
    begin
      fields = @protocol.field_list_command table, field
      return Result.new fields
    rescue ServerError => e
      @last_error = e
      @sqlstate = e.sqlstate
      raise
    end
  end

  # Returns Mysql::Result object containing process list.
  # === Return
  # [Mysql::Result]
  def list_processes
    check_connection
    @fields = @protocol.process_info_command
    @result_exist = true
    store_result
  end

  # Returns list of table name.
  #
  # NOTE for Ruby 1.8: This is not multi-byte safe. Don't use for
  # multi-byte charset such as cp932.
  # === Argument
  # table :: [String] database name that may contain wild card.
  # === Return
  # [Array of String]
  def list_tables(table=nil)
    q = table ? "show tables like '#{quote table}'" : "show tables"
    query(q).map(&:first)
  end

  # Check whether the  connection is available.
  # === Return
  # self
  def ping
    check_connection
    @protocol.ping_command
    self
  end

  # Flush tables or caches.
  # === Argument
  # op :: [Integer] operation. Use Mysql::REFRESH_* value.
  # === Return
  # self
  def refresh(op)
    check_connection
    @protocol.refresh_command op
    self
  end

  # Reload grant tables.
  # === Return
  # self
  def reload
    refresh Mysql::REFRESH_GRANT
  end

  # Select default database
  # === Return
  # self
  def select_db(db)
    query "use #{db}"
    self
  end

  # shutdown server.
  # === Return
  # self
  def shutdown(level=0)
    check_connection
    @protocol.shutdown_command level
    self
  end

  # === Return
  # [String] statistics message
  def stat
    @protocol ? @protocol.statistics_command : 'MySQL server has gone away'
  end

  # Commit transaction
  # === Return
  # self
  def commit
    query 'commit'
    self
  end

  # Rollback transaction
  # === Return
  # self
  def rollback
    query 'rollback'
    self
  end

  # Set autocommit mode
  # === Argument
  # flag :: [true / false]
  # === Return
  # self
  def autocommit(flag)
    query "set autocommit=#{flag ? 1 : 0}"
    self
  end

  private

  def check_connection
    raise ClientError::ServerGoneError, 'The MySQL server has gone away' unless @protocol
  end

  # Field class
  class Field
    attr_reader :db             # database name
    attr_reader :table          # table name
    attr_reader :org_table      # original table name
    attr_reader :name           # field name
    attr_reader :org_name       # original field name
    attr_reader :charsetnr      # charset id number
    attr_reader :length         # field length
    attr_reader :type           # field type
    attr_reader :flags          # flag
    attr_reader :decimals       # number of decimals
    attr_reader :default        # defualt value
    alias :def :default
    attr_accessor :max_length   # maximum width of the field for the result set

    # === Argument
    # [Protocol::FieldPacket]
    def initialize(packet)
      @db, @table, @org_table, @name, @org_name, @charsetnr, @length, @type, @flags, @decimals, @default =
        packet.db, packet.table, packet.org_table, packet.name, packet.org_name, packet.charsetnr, packet.length, packet.type, packet.flags, packet.decimals, packet.default
      @flags |= NUM_FLAG if is_num_type?
    end

    def hash
      {
        "name"       => @name,
        "table"      => @table,
        "def"        => @default,
        "type"       => @type,
        "length"     => @length,
        "max_length" => @max_length,
        "flags"      => @flags,
        "decimals"   => @decimals
      }
    end

    def inspect
      "#<Mysql::Field:#{@name}>"
    end

    # Return true if numeric field.
    def is_num?
      @flags & NUM_FLAG != 0
    end

    # Return true if not null field.
    def is_not_null?
      @flags & NOT_NULL_FLAG != 0
    end

    # Return true if primary key field.
    def is_pri_key?
      @flags & PRI_KEY_FLAG != 0
    end

    private

    def is_num_type?
      [TYPE_DECIMAL, TYPE_TINY, TYPE_SHORT, TYPE_LONG, TYPE_FLOAT, TYPE_DOUBLE, TYPE_LONGLONG, TYPE_INT24].include?(@type) || (@type == TYPE_TIMESTAMP && (@length == 14 || @length == 8))
    end

  end

  # Result set
  class ResultBase
    include Enumerable

    attr_reader :fields

    # === Argument
    # fields :: [Array of Mysql::Field]
    def initialize(fields)
      @fields = fields
      @field_index = 0             # index of field
      @records = []                # all records
      @index = 0                   # index of record
      @fieldname_with_table = nil
    end

    # ignore
    def free
    end

    # === Return
    # [Integer] number of record
    def size
      @records.size
    end
    alias num_rows size

    # Return current record.
    # === Return
    # [Array] record data
    def fetch
      @fetched_record = nil
      return nil if @index >= @records.size
      rec = @records[@index]
      @index += 1
      @fetched_record = rec
      return rec
    end
    alias fetch_row fetch

    # Return data of current record as Hash.
    # The hash key is field name.
    # === Argument
    # with_table :: if true, hash key is "table_name.field_name".
    # === Return
    # [Array of Hash] record data
    def fetch_hash(with_table=nil)
      row = fetch
      return nil unless row
      if with_table and @fieldname_with_table.nil?
        @fieldname_with_table = @fields.map{|f| [f.table, f.name].join(".")}
      end
      ret = {}
      @fields.each_index do |i|
        fname = with_table ? @fieldname_with_table[i] : @fields[i].name
        ret[fname] = row[i]
      end
      ret
    end

    # Iterate block with record.
    # === Block parameter
    # [Array] record data
    # === Return
    # self. If block is not specified, this returns Enumerator.
    def each(&block)
      return enum_for(:each) unless block
      while rec = fetch
        block.call rec
      end
      self
    end

    # Iterate block with record as Hash.
    # === Argument
    # with_table :: if true, hash key is "table_name.field_name".
    # === Block parameter
    # [Array of Hash] record data
    # === Return
    # self. If block is not specified, this returns Enumerator.
    def each_hash(with_table=nil, &block)
      return enum_for(:each_hash, with_table) unless block
      while rec = fetch_hash(with_table)
        block.call rec
      end
      self
    end

    # Set record position
    # === Argument
    # n :: [Integer] record index
    # === Return
    # self
    def data_seek(n)
      @index = n
      self
    end

    # Return current record position
    # === Return
    # [Integer] record position
    def row_tell
      @index
    end

    # Set current position of record
    # === Argument
    # n :: [Integer] record index
    # === Return
    # [Integer] previous position
    def row_seek(n)
      ret = @index
      @index = n
      ret
    end
  end

  # Result set for simple query
  class Result < ResultBase
    def initialize(fields, protocol=nil)
      super fields
      return unless protocol
      @records = protocol.retr_all_records @fields
      # for Field#max_length
      @records.each do |rec|
        rec.zip(fields) do |v, f|
          f.max_length = [v ? v.length : 0, f.max_length || 0].max
        end
      end
    end

    # Return current field
    # === Return
    # [Mysql::Field] field object
    def fetch_field
      return nil if @field_index >= @fields.length
      ret = @fields[@field_index]
      @field_index += 1
      ret
    end

    # Return current position of field
    # === Return
    # [Integer] field position
    def field_tell
      @field_index
    end

    # Set field position
    # === Argument
    # n :: [Integer] field index
    # === Return
    # [Integer] previous position
    def field_seek(n)
      ret = @field_index
      @field_index = n
      ret
    end

    # Return field
    # === Argument
    # n :: [Integer] field index
    # === Return
    # [Mysql::Field] field
    def fetch_field_direct(n)
      raise ClientError, "invalid argument: #{n}" if n < 0 or n >= @fields.length
      @fields[n]
    end

    # Return all fields
    # === Return
    # [Array of Mysql::Field] all fields
    def fetch_fields
      @fields
    end

    # Return length of each fields
    # === Return
    # [Array of Integer] length of each fields
    def fetch_lengths
      return nil unless @fetched_record
      @fetched_record.map{|c|c.nil? ? 0 : c.length}
    end

    # === Return
    # [Integer] number of fields
    def num_fields
      @fields.size
    end
  end

  # Result set for prepared statement
  class StatementResult < ResultBase
    def initialize(fields, protocol, charset)
      super fields
      @records = protocol.stmt_retr_all_records @fields, charset
    end
  end

  # Prepared statement
  class Stmt
    include Enumerable

    attr_reader :affected_rows, :insert_id, :server_status, :warning_count
    attr_reader :param_count, :fields, :sqlstate

    def self.finalizer(protocol, statement_id)
      proc do
        protocol.gc_stmt statement_id
      end
    end

    def initialize(protocol, charset)
      @protocol = protocol;@charset = charset;@statement_id = nil;@affected_rows = @insert_id = @server_status = @warning_count = 0;@sqlstate = "00000";@param_count = nil
    end

    def prepare(str)
      close
      begin
        @sqlstate = "00000";@statement_id, @param_count, @fields = @protocol.stmt_prepare_command(str)
      rescue ServerError => e
        @last_error = e;@sqlstate = e.sqlstate
        raise
      end
      ObjectSpace.define_finalizer(self, self.class.finalizer(@protocol, @statement_id))
      self
    end

    def execute(*values)
      raise ClientError, "not prepared" unless @param_count
      raise ClientError, "parameter count mismatch" if values.length != @param_count
      values = values.map{|v| @charset.convert v}
      begin
        @sqlstate = "00000"
        nfields = @protocol.stmt_execute_command @statement_id, values
        if nfields
          @fields = @protocol.retr_fields nfields
          @result = StatementResult.new @fields, @protocol, @charset
        else
          @affected_rows, @insert_id, @server_status, @warning_count, @info =
            @protocol.affected_rows, @protocol.insert_id, @protocol.server_status, @protocol.warning_count, @protocol.message
        end
        return self
      rescue ServerError => e
        @last_error = e
        @sqlstate = e.sqlstate
        raise
      end
    end

    # Close prepared statement
    def close
      ObjectSpace.undefine_finalizer(self)
      @protocol.stmt_close_command @statement_id if @statement_id
      @statement_id = nil
    end

    def fetch
      row = @result.fetch
      return row unless @bind_result
      row.zip(@bind_result).map do |col, type|
        if col.nil?
          nil
        elsif [Numeric, Integer, Fixnum].include? type
          col.to_i
        elsif type == String
          col.to_s
        elsif type == Float && !col.is_a?(Float)
          col.to_i.to_f
        elsif type == Mysql::Time && !col.is_a?(Mysql::Time)
          if col.to_s =~ /\A\d+\z/
            i = col.to_s.to_i
            if i < 100000000
              y = i/10000;m = i/100%100;d = i%100;h, mm, s = 0
            else
              y = i/10000000000;m = i/100000000%100;d = i/1000000%100;h = i/10000%100;mm= i/100%100;s = i%100
            end
            if y < 70
              y += 2000
            elsif y < 100
              y += 1900
            end
            Mysql::Time.new(y, m, d, h, mm, s)
          else
            Mysql::Time.new
          end
        else
          col
        end
      end
    end

    def fetch_hash(with_table=nil)
      @result.fetch_hash with_table
    end

    def bind_result(*args)
      if @fields.length != args.length
        raise ClientError, "bind_result: result value count(#{@fields.length}) != number of argument(#{args.length})"
      end
      args.each do |a|
        raise TypeError unless [Numeric, Fixnum, Integer, Float, String, Mysql::Time, nil].include? a
      end
      @bind_result = args
      self
    end

    def each(&block)
      return enum_for(:each) unless block
      while rec = fetch
        block.call rec
      end
      self
    end

    def each_hash(with_table=nil, &block)
      return enum_for(:each_hash, with_table) unless block
      while rec = fetch_hash(with_table)
        block.call rec
      end
      self
    end

    def size
      @result.size
    end
    alias num_rows size

    def data_seek(n)
      @result.data_seek(n)
    end

    def row_tell
      @result.row_tell
    end

    def row_seek(n)
      @result.row_seek(n)
    end

    def field_count
      @fields.length
    end

    # ignore
    def free_result
    end

    def result_metadata
      return nil if @fields.empty?
      Result.new @fields
    end
  end

  class Time
    def initialize(year=0, month=0, day=0, hour=0, minute=0, second=0, neg=false, second_part=0)
      @year, @month, @day, @hour, @minute, @second, @neg, @second_part =
        year.to_i, month.to_i, day.to_i, hour.to_i, minute.to_i, second.to_i, neg, second_part.to_i
    end
    attr_accessor :year, :month, :day, :hour, :minute, :second, :neg, :second_part
    alias mon month
    alias min minute
    alias sec second

    def ==(other) # :nodoc:
      other.is_a?(Mysql::Time) &&
        @year == other.year && @month == other.month && @day == other.day &&
        @hour == other.hour && @minute == other.minute && @second == other.second &&
        @neg == neg && @second_part == other.second_part
    end

    def eql?(other) # :nodoc:
      self == other
    end

    def to_s
      if year == 0 and mon == 0 and day == 0
        h = neg ? hour * -1 : hour
        sprintf "%02d:%02d:%02d", h, min, sec
      else
        sprintf "%04d-%02d-%02d %02d:%02d:%02d", year, mon, day, hour, min, sec
      end
    end

    def to_i
      sprintf("%04d%02d%02d%02d%02d%02d", year, mon, day, hour, min, sec).to_i
    end

    def inspect # :nodoc:
      sprintf "#<#{self.class.name}:%04d-%02d-%02d %02d:%02d:%02d>", year, mon, day, hour, min, sec
    end

  end

end
